<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>B++: TreeAVL&lt; Key, T, Compare, Allocator &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">B++
   </div>
   <div id="projectbrief">A general purpose C++ library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle"><div class="title">TreeAVL&lt; Key, T, Compare, Allocator &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="../../da/d53/class_tree_a_v_l.html" title="TreeAVL is a sorted associative container that contains key-value pairs with unique keys....">TreeAVL</a> is a sorted associative container that contains key-value pairs with unique keys. Keys are sorted by using the comparison function Compare. Search, removal, and insertion operations have logarithmic complexity. This is an implementation of an Adelson-Velsky and Landis Tree.  
 <a href="../../da/d53/class_tree_a_v_l.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../db/d18/_tree_a_v_l_8h_source.html">TreeAVL.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d29/class_tree_a_v_l_1_1iterator.html">iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterator is an object that allows iteration of the container in the order of the sorted keys. Beware that any changes in the tree may invalidate the iterators and produce undefined behaviour.  <a href="../../d5/d29/class_tree_a_v_l_1_1iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d8f/class_tree_a_v_l_1_1reverse__iterator.html">reverse_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d1/d8f/class_tree_a_v_l_1_1reverse__iterator.html" title="reverse_iterator is an object that allows iteration of the container in the inverse order of the sort...">reverse_iterator</a> is an object that allows iteration of the container in the inverse order of the sorted keys. Beware that any changes in the tree may invalidate the iterators and produce undefined behaviour.  <a href="../../d1/d8f/class_tree_a_v_l_1_1reverse__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a81e22101e5cbb5310ad16569d0646454"><td class="memItemLeft" align="right" valign="top"><a id="a81e22101e5cbb5310ad16569d0646454" name="a81e22101e5cbb5310ad16569d0646454"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TreeAVL</b> ()</td></tr>
<tr class="memdesc:a81e22101e5cbb5310ad16569d0646454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty container. <br /></td></tr>
<tr class="separator:a81e22101e5cbb5310ad16569d0646454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9314352ac05df48dd30c6f6453063fdd"><td class="memTemplParams" colspan="2"><a id="a9314352ac05df48dd30c6f6453063fdd" name="a9314352ac05df48dd30c6f6453063fdd"></a>
template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a9314352ac05df48dd30c6f6453063fdd"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TreeAVL</b> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a9314352ac05df48dd30c6f6453063fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the range [first, last). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted. <br /></td></tr>
<tr class="separator:a9314352ac05df48dd30c6f6453063fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8abe5a32f8b0d5563d9811069a447a"><td class="memItemLeft" align="right" valign="top"><a id="a2f8abe5a32f8b0d5563d9811069a447a" name="a2f8abe5a32f8b0d5563d9811069a447a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TreeAVL</b> (const <a class="el" href="../../da/d53/class_tree_a_v_l.html">TreeAVL</a> &amp;other)</td></tr>
<tr class="memdesc:a2f8abe5a32f8b0d5563d9811069a447a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. Constructs the container with the copy of the contents of other. <br /></td></tr>
<tr class="separator:a2f8abe5a32f8b0d5563d9811069a447a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba7a523d39abcd2f6a90207a363cd3aa"><td class="memItemLeft" align="right" valign="top"><a id="aba7a523d39abcd2f6a90207a363cd3aa" name="aba7a523d39abcd2f6a90207a363cd3aa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TreeAVL</b> (<a class="el" href="../../da/d53/class_tree_a_v_l.html">TreeAVL</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:aba7a523d39abcd2f6a90207a363cd3aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. Constructs the container with the contents of other using move semantics. <br /></td></tr>
<tr class="separator:aba7a523d39abcd2f6a90207a363cd3aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2840363c97c136fb6e8f160beec15d"><td class="memItemLeft" align="right" valign="top"><a id="a5a2840363c97c136fb6e8f160beec15d" name="a5a2840363c97c136fb6e8f160beec15d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TreeAVL</b> (std::initializer_list&lt; std::pair&lt; const Key, T &gt; &gt; ilist)</td></tr>
<tr class="memdesc:a5a2840363c97c136fb6e8f160beec15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the initializer list init. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted. <br /></td></tr>
<tr class="separator:a5a2840363c97c136fb6e8f160beec15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e84334f60d86836e3dc245a9b8da4f5"><td class="memItemLeft" align="right" valign="top"><a id="a5e84334f60d86836e3dc245a9b8da4f5" name="a5e84334f60d86836e3dc245a9b8da4f5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~TreeAVL</b> ()</td></tr>
<tr class="memdesc:a5e84334f60d86836e3dc245a9b8da4f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructs the map. The destructors of the elements are called and the used storage is deallocated. Note, that if the elements are pointers, the pointed-to objects are not destroyed. <br /></td></tr>
<tr class="separator:a5e84334f60d86836e3dc245a9b8da4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe079f4c39d71a4ee625f1e12935f11"><td class="memItemLeft" align="right" valign="top"><a id="a7fe079f4c39d71a4ee625f1e12935f11" name="a7fe079f4c39d71a4ee625f1e12935f11"></a>
<a class="el" href="../../da/d53/class_tree_a_v_l.html">TreeAVL</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="../../da/d53/class_tree_a_v_l.html">TreeAVL</a> &amp;other)</td></tr>
<tr class="memdesc:a7fe079f4c39d71a4ee625f1e12935f11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of other. <br /></td></tr>
<tr class="separator:a7fe079f4c39d71a4ee625f1e12935f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab149b7d492ba1afd228f8b6b5f9305e3"><td class="memItemLeft" align="right" valign="top"><a id="ab149b7d492ba1afd228f8b6b5f9305e3" name="ab149b7d492ba1afd228f8b6b5f9305e3"></a>
<a class="el" href="../../da/d53/class_tree_a_v_l.html">TreeAVL</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="../../da/d53/class_tree_a_v_l.html">TreeAVL</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:ab149b7d492ba1afd228f8b6b5f9305e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in other is moved from other into this container). <br /></td></tr>
<tr class="separator:ab149b7d492ba1afd228f8b6b5f9305e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe26c7d9024e9dbd74d0dad842fec42"><td class="memItemLeft" align="right" valign="top"><a id="a2fe26c7d9024e9dbd74d0dad842fec42" name="a2fe26c7d9024e9dbd74d0dad842fec42"></a>
<a class="el" href="../../da/d53/class_tree_a_v_l.html">TreeAVL</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (std::initializer_list&lt; std::pair&lt; const Key, T &gt; &gt; ilist)</td></tr>
<tr class="memdesc:a2fe26c7d9024e9dbd74d0dad842fec42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with those identified by initializer list ilist. <br /></td></tr>
<tr class="separator:a2fe26c7d9024e9dbd74d0dad842fec42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444119a409f4df351f719dbc88f9d2db"><td class="memItemLeft" align="right" valign="top"><a id="a444119a409f4df351f719dbc88f9d2db" name="a444119a409f4df351f719dbc88f9d2db"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>at</b> (const Key &amp;key) const</td></tr>
<tr class="memdesc:a444119a409f4df351f719dbc88f9d2db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the mapped value of the element with key equivalent to key. If no such element exists, an exception of type std::out_of_range is thrown. <br /></td></tr>
<tr class="separator:a444119a409f4df351f719dbc88f9d2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae357a664f4f27c529c698bdb81ce8749"><td class="memItemLeft" align="right" valign="top"><a id="ae357a664f4f27c529c698bdb81ce8749" name="ae357a664f4f27c529c698bdb81ce8749"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (const Key &amp;key)</td></tr>
<tr class="memdesc:ae357a664f4f27c529c698bdb81ce8749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the value that is mapped to a key equivalent to key, performing an insertion if such key does not already exist. <br /></td></tr>
<tr class="separator:ae357a664f4f27c529c698bdb81ce8749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4f474efa33b50d51251cf4268410da9"><td class="memItemLeft" align="right" valign="top"><a id="aa4f474efa33b50d51251cf4268410da9" name="aa4f474efa33b50d51251cf4268410da9"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (Key &amp;&amp;key)</td></tr>
<tr class="memdesc:aa4f474efa33b50d51251cf4268410da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the value that is mapped to a key equivalent to key, performing an insertion if such key does not already exist. <br /></td></tr>
<tr class="separator:aa4f474efa33b50d51251cf4268410da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df8abae0918bc2d24211585476b0385"><td class="memItemLeft" align="right" valign="top"><a id="a3df8abae0918bc2d24211585476b0385" name="a3df8abae0918bc2d24211585476b0385"></a>
<a class="el" href="../../d5/d29/class_tree_a_v_l_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const noexcept</td></tr>
<tr class="memdesc:a3df8abae0918bc2d24211585476b0385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the map. If the map is empty, the returned iterator will be equal to <a class="el" href="../../da/d53/class_tree_a_v_l.html#a71b870a54749e1e5c3aa2274b484f6e0" title="Returns an iterator to the element following the last element of the map. This element acts as a plac...">end()</a>. <br /></td></tr>
<tr class="separator:a3df8abae0918bc2d24211585476b0385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b870a54749e1e5c3aa2274b484f6e0"><td class="memItemLeft" align="right" valign="top"><a id="a71b870a54749e1e5c3aa2274b484f6e0" name="a71b870a54749e1e5c3aa2274b484f6e0"></a>
<a class="el" href="../../d5/d29/class_tree_a_v_l_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const noexcept</td></tr>
<tr class="memdesc:a71b870a54749e1e5c3aa2274b484f6e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the map. This element acts as a placeholder; attempting to access it results in undefined behavior. <br /></td></tr>
<tr class="separator:a71b870a54749e1e5c3aa2274b484f6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8c256924fc24757be8a0425576ad37"><td class="memItemLeft" align="right" valign="top"><a id="aac8c256924fc24757be8a0425576ad37" name="aac8c256924fc24757be8a0425576ad37"></a>
<a class="el" href="../../d1/d8f/class_tree_a_v_l_1_1reverse__iterator.html">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rbegin</b> () const noexcept</td></tr>
<tr class="memdesc:aac8c256924fc24757be8a0425576ad37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed map. It corresponds to the last element of the non-reversed map. If the map is empty, the returned iterator is equal to <a class="el" href="../../da/d53/class_tree_a_v_l.html#ad385bc03069a2f530b5ee351a755a98f" title="Returns a reverse iterator to the element following the last element of the reversed map....">rend()</a>. <br /></td></tr>
<tr class="separator:aac8c256924fc24757be8a0425576ad37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad385bc03069a2f530b5ee351a755a98f"><td class="memItemLeft" align="right" valign="top"><a id="ad385bc03069a2f530b5ee351a755a98f" name="ad385bc03069a2f530b5ee351a755a98f"></a>
<a class="el" href="../../d1/d8f/class_tree_a_v_l_1_1reverse__iterator.html">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rend</b> () const noexcept</td></tr>
<tr class="memdesc:ad385bc03069a2f530b5ee351a755a98f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed map. It corresponds to the element preceding the first element of the non-reversed map. This element acts as a placeholder, attempting to access it results in undefined behavior. <br /></td></tr>
<tr class="separator:ad385bc03069a2f530b5ee351a755a98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff59da0701c986193d824d6056b1631a"><td class="memItemLeft" align="right" valign="top"><a id="aff59da0701c986193d824d6056b1631a" name="aff59da0701c986193d824d6056b1631a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty</b> () const noexcept</td></tr>
<tr class="memdesc:aff59da0701c986193d824d6056b1631a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the container has no elements, i.e. whether <a class="el" href="../../da/d53/class_tree_a_v_l.html#a3df8abae0918bc2d24211585476b0385" title="Returns an iterator to the first element of the map. If the map is empty, the returned iterator will ...">begin()</a> == <a class="el" href="../../da/d53/class_tree_a_v_l.html#a71b870a54749e1e5c3aa2274b484f6e0" title="Returns an iterator to the element following the last element of the map. This element acts as a plac...">end()</a>. <br /></td></tr>
<tr class="separator:aff59da0701c986193d824d6056b1631a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc7fcbb1e5bbba8fd64652b4a27153b"><td class="memItemLeft" align="right" valign="top"><a id="afbc7fcbb1e5bbba8fd64652b4a27153b" name="afbc7fcbb1e5bbba8fd64652b4a27153b"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const noexcept</td></tr>
<tr class="memdesc:afbc7fcbb1e5bbba8fd64652b4a27153b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the container. <br /></td></tr>
<tr class="separator:afbc7fcbb1e5bbba8fd64652b4a27153b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616297ef38bbb06034dee80a9d806b3c"><td class="memItemLeft" align="right" valign="top"><a id="a616297ef38bbb06034dee80a9d806b3c" name="a616297ef38bbb06034dee80a9d806b3c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> () noexcept</td></tr>
<tr class="memdesc:a616297ef38bbb06034dee80a9d806b3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements from the container. After this call, <a class="el" href="../../da/d53/class_tree_a_v_l.html#afbc7fcbb1e5bbba8fd64652b4a27153b" title="Returns the number of elements in the container.">size()</a> returns zero. Invalidates any references, pointers, or iterators referring to contained elements. Any past-the-end iterator remains valid. <br /></td></tr>
<tr class="separator:a616297ef38bbb06034dee80a9d806b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84ad863e988fb07fdae8ea27889d78f"><td class="memItemLeft" align="right" valign="top"><a id="aa84ad863e988fb07fdae8ea27889d78f" name="aa84ad863e988fb07fdae8ea27889d78f"></a>
std::pair&lt; <a class="el" href="../../d5/d29/class_tree_a_v_l_1_1iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (const std::pair&lt; const Key, T &gt; &amp;value)</td></tr>
<tr class="memdesc:aa84ad863e988fb07fdae8ea27889d78f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. Returns a pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool denoting whether the insertion took place. <br /></td></tr>
<tr class="separator:aa84ad863e988fb07fdae8ea27889d78f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7af14fcda9a480653998f2a6fcd13e4"><td class="memItemLeft" align="right" valign="top"><a id="aa7af14fcda9a480653998f2a6fcd13e4" name="aa7af14fcda9a480653998f2a6fcd13e4"></a>
std::pair&lt; <a class="el" href="../../d5/d29/class_tree_a_v_l_1_1iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (std::pair&lt; const Key, T &gt; &amp;&amp;value)</td></tr>
<tr class="memdesc:aa7af14fcda9a480653998f2a6fcd13e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. Returns a pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool denoting whether the insertion took place. <br /></td></tr>
<tr class="separator:aa7af14fcda9a480653998f2a6fcd13e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26cc4b19055bf7b8842ca64f3a77a09a"><td class="memItemLeft" align="right" valign="top"><a id="a26cc4b19055bf7b8842ca64f3a77a09a" name="a26cc4b19055bf7b8842ca64f3a77a09a"></a>
<a class="el" href="../../d5/d29/class_tree_a_v_l_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (iterator_base hint, const std::pair&lt; const Key, T &gt; &amp;value)</td></tr>
<tr class="memdesc:a26cc4b19055bf7b8842ca64f3a77a09a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts value in the position as close as possible to hint. Returns an iterator to the inserted element, or to the element that prevented the insertion. <br /></td></tr>
<tr class="separator:a26cc4b19055bf7b8842ca64f3a77a09a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee9e082b9bb1361b63f288df0b9a91d"><td class="memItemLeft" align="right" valign="top"><a id="a6ee9e082b9bb1361b63f288df0b9a91d" name="a6ee9e082b9bb1361b63f288df0b9a91d"></a>
<a class="el" href="../../d5/d29/class_tree_a_v_l_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (iterator_base hint, std::pair&lt; const Key, T &gt; &amp;&amp;value)</td></tr>
<tr class="memdesc:a6ee9e082b9bb1361b63f288df0b9a91d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts value in the position as close as possible to hint. Returns an iterator to the inserted element, or to the element that prevented the insertion. <br /></td></tr>
<tr class="separator:a6ee9e082b9bb1361b63f288df0b9a91d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36b020da0ba4cdf726760765768a4fa"><td class="memTemplParams" colspan="2"><a id="ad36b020da0ba4cdf726760765768a4fa" name="ad36b020da0ba4cdf726760765768a4fa"></a>
template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:ad36b020da0ba4cdf726760765768a4fa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert</b> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:ad36b020da0ba4cdf726760765768a4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from range [first, last). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted. <br /></td></tr>
<tr class="separator:ad36b020da0ba4cdf726760765768a4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef6842d07bf79131432ca12d677175c"><td class="memItemLeft" align="right" valign="top"><a id="a0ef6842d07bf79131432ca12d677175c" name="a0ef6842d07bf79131432ca12d677175c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (std::initializer_list&lt; std::pair&lt; const Key, T &gt; &gt; ilist)</td></tr>
<tr class="memdesc:a0ef6842d07bf79131432ca12d677175c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from initializer list ilist. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted. <br /></td></tr>
<tr class="separator:a0ef6842d07bf79131432ca12d677175c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0cf2d3bfd6aaa33356297071cda256"><td class="memTemplParams" colspan="2"><a id="aae0cf2d3bfd6aaa33356297071cda256" name="aae0cf2d3bfd6aaa33356297071cda256"></a>
template&lt;class M &gt; </td></tr>
<tr class="memitem:aae0cf2d3bfd6aaa33356297071cda256"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="../../d5/d29/class_tree_a_v_l_1_1iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_or_assign</b> (const Key &amp;k, M &amp;&amp;obj)</td></tr>
<tr class="memdesc:aae0cf2d3bfd6aaa33356297071cda256"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a key equivalent to k already exists in the container, assigns obj to the mapped_type corresponding to the key k. If the key does not exist, inserts the new value as if by insert. <br /></td></tr>
<tr class="separator:aae0cf2d3bfd6aaa33356297071cda256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac126f53eaa06a6237a9f66484027474d"><td class="memTemplParams" colspan="2"><a id="ac126f53eaa06a6237a9f66484027474d" name="ac126f53eaa06a6237a9f66484027474d"></a>
template&lt;class M &gt; </td></tr>
<tr class="memitem:ac126f53eaa06a6237a9f66484027474d"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="../../d5/d29/class_tree_a_v_l_1_1iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_or_assign</b> (Key &amp;&amp;k, M &amp;&amp;obj)</td></tr>
<tr class="memdesc:ac126f53eaa06a6237a9f66484027474d"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a key equivalent to k already exists in the container, assigns obj to the mapped_type corresponding to the key k. If the key does not exist, inserts the new value as if by insert. <br /></td></tr>
<tr class="separator:ac126f53eaa06a6237a9f66484027474d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f824ba52f3912e0165faf530071a38"><td class="memTemplParams" colspan="2"><a id="aa5f824ba52f3912e0165faf530071a38" name="aa5f824ba52f3912e0165faf530071a38"></a>
template&lt;class M &gt; </td></tr>
<tr class="memitem:aa5f824ba52f3912e0165faf530071a38"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="../../d5/d29/class_tree_a_v_l_1_1iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_or_assign</b> (iterator_base hint, const Key &amp;k, M &amp;&amp;obj)</td></tr>
<tr class="memdesc:aa5f824ba52f3912e0165faf530071a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a key equivalent to k already exists in the container, assigns obj to the mapped_type corresponding to the key k. If the key does not exist, inserts the new value as if by insert. <br /></td></tr>
<tr class="separator:aa5f824ba52f3912e0165faf530071a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f7a1b2eb946ce515a1cd98cde99f18"><td class="memTemplParams" colspan="2"><a id="a37f7a1b2eb946ce515a1cd98cde99f18" name="a37f7a1b2eb946ce515a1cd98cde99f18"></a>
template&lt;class M &gt; </td></tr>
<tr class="memitem:a37f7a1b2eb946ce515a1cd98cde99f18"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="../../d5/d29/class_tree_a_v_l_1_1iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_or_assign</b> (iterator_base hint, Key &amp;&amp;k, M &amp;&amp;obj)</td></tr>
<tr class="memdesc:a37f7a1b2eb946ce515a1cd98cde99f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a key equivalent to k already exists in the container, assigns obj to the mapped_type corresponding to the key k. If the key does not exist, inserts the new value as if by insert. <br /></td></tr>
<tr class="separator:a37f7a1b2eb946ce515a1cd98cde99f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d9a58141992476b3fc360ada7692df"><td class="memItemLeft" align="right" valign="top"><a id="aa8d9a58141992476b3fc360ada7692df" name="aa8d9a58141992476b3fc360ada7692df"></a>
<a class="el" href="../../d5/d29/class_tree_a_v_l_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (<a class="el" href="../../d5/d29/class_tree_a_v_l_1_1iterator.html">iterator</a> pos)</td></tr>
<tr class="memdesc:aa8d9a58141992476b3fc360ada7692df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes element at pos from the container. Returns iterator following the last removed element. <br /></td></tr>
<tr class="separator:aa8d9a58141992476b3fc360ada7692df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2405eb1c4e7fb964af45d111b1cd53"><td class="memItemLeft" align="right" valign="top"><a id="a6c2405eb1c4e7fb964af45d111b1cd53" name="a6c2405eb1c4e7fb964af45d111b1cd53"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (const Key &amp;key)</td></tr>
<tr class="memdesc:a6c2405eb1c4e7fb964af45d111b1cd53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element (if one exists) with the key equivalent to key. Returns the number of elements removed (0 or 1). <br /></td></tr>
<tr class="separator:a6c2405eb1c4e7fb964af45d111b1cd53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852c2abac4542cc91ce300e87ec04044"><td class="memTemplParams" colspan="2"><a id="a852c2abac4542cc91ce300e87ec04044" name="a852c2abac4542cc91ce300e87ec04044"></a>
template&lt;class K &gt; </td></tr>
<tr class="memitem:a852c2abac4542cc91ce300e87ec04044"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>erase</b> (K &amp;&amp;key)</td></tr>
<tr class="memdesc:a852c2abac4542cc91ce300e87ec04044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element (if one exists) with the key equivalent to key. Returns the number of elements removed (0 or 1). <br /></td></tr>
<tr class="separator:a852c2abac4542cc91ce300e87ec04044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8205a4fbaf4b40b5f178a1639f85090"><td class="memTemplParams" colspan="2"><a id="af8205a4fbaf4b40b5f178a1639f85090" name="af8205a4fbaf4b40b5f178a1639f85090"></a>
template&lt;class K &gt; </td></tr>
<tr class="memitem:af8205a4fbaf4b40b5f178a1639f85090"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>count</b> (const K &amp;key) const</td></tr>
<tr class="memdesc:af8205a4fbaf4b40b5f178a1639f85090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements with key that compares equivalent to the specified argument, which is either 1 or 0 since this container does not allow duplicates. <br /></td></tr>
<tr class="separator:af8205a4fbaf4b40b5f178a1639f85090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20144b488912fba5c32d0571b1c52498"><td class="memTemplParams" colspan="2"><a id="a20144b488912fba5c32d0571b1c52498" name="a20144b488912fba5c32d0571b1c52498"></a>
template&lt;class K &gt; </td></tr>
<tr class="memitem:a20144b488912fba5c32d0571b1c52498"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/d29/class_tree_a_v_l_1_1iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find</b> (const K &amp;key)</td></tr>
<tr class="memdesc:a20144b488912fba5c32d0571b1c52498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equivalent to key and returns an iterator to the element. If no such element is found, past-the-end (see <a class="el" href="../../da/d53/class_tree_a_v_l.html#a71b870a54749e1e5c3aa2274b484f6e0" title="Returns an iterator to the element following the last element of the map. This element acts as a plac...">end()</a>) iterator is returned. <br /></td></tr>
<tr class="separator:a20144b488912fba5c32d0571b1c52498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa20b71d6c7cd55d42b09f3148dc6ade"><td class="memTemplParams" colspan="2"><a id="aaa20b71d6c7cd55d42b09f3148dc6ade" name="aaa20b71d6c7cd55d42b09f3148dc6ade"></a>
template&lt;class K &gt; </td></tr>
<tr class="memitem:aaa20b71d6c7cd55d42b09f3148dc6ade"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>contains</b> (const K &amp;key) const</td></tr>
<tr class="memdesc:aaa20b71d6c7cd55d42b09f3148dc6ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there is an element with key that compares equivalent to the value x. <br /></td></tr>
<tr class="separator:aaa20b71d6c7cd55d42b09f3148dc6ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c553e36843bf3beeb3f9dfd5f4dcd0"><td class="memTemplParams" colspan="2"><a id="a34c553e36843bf3beeb3f9dfd5f4dcd0" name="a34c553e36843bf3beeb3f9dfd5f4dcd0"></a>
template&lt;class K &gt; </td></tr>
<tr class="memitem:a34c553e36843bf3beeb3f9dfd5f4dcd0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/d29/class_tree_a_v_l_1_1iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>lower_bound</b> (const K &amp;key)</td></tr>
<tr class="memdesc:a34c553e36843bf3beeb3f9dfd5f4dcd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that compares not less (i.e. greater or equal) to the value x. <br /></td></tr>
<tr class="separator:a34c553e36843bf3beeb3f9dfd5f4dcd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bcb85ead671c83c8f7f71dea2748961"><td class="memTemplParams" colspan="2"><a id="a7bcb85ead671c83c8f7f71dea2748961" name="a7bcb85ead671c83c8f7f71dea2748961"></a>
template&lt;class K &gt; </td></tr>
<tr class="memitem:a7bcb85ead671c83c8f7f71dea2748961"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/d29/class_tree_a_v_l_1_1iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>upper_bound</b> (const K &amp;key)</td></tr>
<tr class="memdesc:a7bcb85ead671c83c8f7f71dea2748961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that compares greater to the value x. <br /></td></tr>
<tr class="separator:a7bcb85ead671c83c8f7f71dea2748961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028af2d4ab0a7020ba41899733d01b9e"><td class="memTemplParams" colspan="2"><a id="a028af2d4ab0a7020ba41899733d01b9e" name="a028af2d4ab0a7020ba41899733d01b9e"></a>
template&lt;class K &gt; </td></tr>
<tr class="memitem:a028af2d4ab0a7020ba41899733d01b9e"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="../../d5/d29/class_tree_a_v_l_1_1iterator.html">iterator</a>, <a class="el" href="../../d5/d29/class_tree_a_v_l_1_1iterator.html">iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>equal_range</b> (const K &amp;key)</td></tr>
<tr class="memdesc:a028af2d4ab0a7020ba41899733d01b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="../../da/d53/class_tree_a_v_l.html#a34c553e36843bf3beeb3f9dfd5f4dcd0" title="Returns an iterator pointing to the first element that compares not less (i.e. greater or equal) to t...">lower_bound()</a>, and the second with <a class="el" href="../../da/d53/class_tree_a_v_l.html#a7bcb85ead671c83c8f7f71dea2748961" title="Returns an iterator pointing to the first element that compares greater to the value x.">upper_bound()</a>. <br /></td></tr>
<tr class="separator:a028af2d4ab0a7020ba41899733d01b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a6b280f5a0fc6c28d5fc1c182f34ecd1f"><td class="memTemplParams" colspan="2"><a id="a6b280f5a0fc6c28d5fc1c182f34ecd1f" name="a6b280f5a0fc6c28d5fc1c182f34ecd1f"></a>
template&lt;class A , class B , class C , class D &gt; </td></tr>
<tr class="memitem:a6b280f5a0fc6c28d5fc1c182f34ecd1f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../da/d53/class_tree_a_v_l.html">TreeAVL</a>&lt; A, B, C, D &gt; &amp;lhs, const <a class="el" href="../../da/d53/class_tree_a_v_l.html">TreeAVL</a>&lt; A, B, C, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a6b280f5a0fc6c28d5fc1c182f34ecd1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the contents of lhs and rhs are equal, that is, they have the same number of elements and each element in lhs compares equal with the element in rhs at the same position. <br /></td></tr>
<tr class="separator:a6b280f5a0fc6c28d5fc1c182f34ecd1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbde3aab88ccc3d13f15f43dc4004e0b"><td class="memTemplParams" colspan="2"><a id="afbde3aab88ccc3d13f15f43dc4004e0b" name="afbde3aab88ccc3d13f15f43dc4004e0b"></a>
template&lt;class A , class B , class C , class D &gt; </td></tr>
<tr class="memitem:afbde3aab88ccc3d13f15f43dc4004e0b"><td class="memTemplItemLeft" align="right" valign="top">std::strong_ordering&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=&gt;</b> (const <a class="el" href="../../da/d53/class_tree_a_v_l.html">TreeAVL</a>&lt; A, B, C, D &gt; &amp;lhs, const <a class="el" href="../../da/d53/class_tree_a_v_l.html">TreeAVL</a>&lt; A, B, C, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:afbde3aab88ccc3d13f15f43dc4004e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of lhs and rhs lexicographically. <br /></td></tr>
<tr class="separator:afbde3aab88ccc3d13f15f43dc4004e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ffc5a9552b28032ae6175764a96ef5"><td class="memTemplParams" colspan="2"><a id="ab5ffc5a9552b28032ae6175764a96ef5" name="ab5ffc5a9552b28032ae6175764a96ef5"></a>
template&lt;class A , class B , class C , class D , class Pred &gt; </td></tr>
<tr class="memitem:ab5ffc5a9552b28032ae6175764a96ef5"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>erase_if</b> (<a class="el" href="../../da/d53/class_tree_a_v_l.html">TreeAVL</a>&lt; A, B, C, D &gt; &amp;tree, Pred pred)</td></tr>
<tr class="memdesc:ab5ffc5a9552b28032ae6175764a96ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements that satisfy the predicate pred from the container. <br /></td></tr>
<tr class="separator:ab5ffc5a9552b28032ae6175764a96ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class Key, class T, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;<br />
class TreeAVL&lt; Key, T, Compare, Allocator &gt;</div><p ><a class="el" href="../../da/d53/class_tree_a_v_l.html" title="TreeAVL is a sorted associative container that contains key-value pairs with unique keys....">TreeAVL</a> is a sorted associative container that contains key-value pairs with unique keys. Keys are sorted by using the comparison function Compare. Search, removal, and insertion operations have logarithmic complexity. This is an implementation of an Adelson-Velsky and Landis Tree. </p>
</div><hr/>The documentation for this class was generated from the following file:<ul>
<li>Collections/<a class="el" href="../../db/d18/_tree_a_v_l_8h_source.html">TreeAVL.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
