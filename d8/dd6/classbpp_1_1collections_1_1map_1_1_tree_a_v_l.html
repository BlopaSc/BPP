<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>B++ Library: bpp::collections::map::TreeAVL&lt; Key, T, Compare, Allocator &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">B++ Library
   </div>
   <div id="projectbrief">A general purpose C++ library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d3/dd4/namespacebpp.html">bpp</a></li><li class="navelem"><a class="el" href="../../d0/d04/namespacebpp_1_1collections.html">collections</a></li><li class="navelem"><a class="el" href="../../d3/d6c/namespacebpp_1_1collections_1_1map.html">map</a></li><li class="navelem"><a class="el" href="../../d8/dd6/classbpp_1_1collections_1_1map_1_1_tree_a_v_l.html">TreeAVL</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle"><div class="title">bpp::collections::map::TreeAVL&lt; Key, T, Compare, Allocator &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="../../d8/dd6/classbpp_1_1collections_1_1map_1_1_tree_a_v_l.html" title="TreeAVL is a sorted associative container that contains key-value pairs with unique keys....">TreeAVL</a> is a sorted associative container that contains key-value pairs with unique keys. Keys are sorted by using the comparison function Compare. Search, removal, and insertion operations have logarithmic complexity. This is an implementation of an Adelson-Velsky and Landis Tree.  
 <a href="../../d8/dd6/classbpp_1_1collections_1_1map_1_1_tree_a_v_l.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../db/d18/_tree_a_v_l_8h_source.html">TreeAVL.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d33/structbpp_1_1collections_1_1map_1_1_tree_a_v_l_1_1iterator.html">iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterator is an object that allows iteration of the container in the order of the sorted keys. Beware that any changes in the tree may invalidate the iterators and produce undefined behaviour.  <a href="../../d8/d33/structbpp_1_1collections_1_1map_1_1_tree_a_v_l_1_1iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dd0/structbpp_1_1collections_1_1map_1_1_tree_a_v_l_1_1reverse__iterator.html">reverse_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d7/dd0/structbpp_1_1collections_1_1map_1_1_tree_a_v_l_1_1reverse__iterator.html" title="reverse_iterator is an object that allows iteration of the container in the inverse order of the sort...">reverse_iterator</a> is an object that allows iteration of the container in the inverse order of the sorted keys. Beware that any changes in the tree may invalidate the iterators and produce undefined behaviour.  <a href="../../d7/dd0/structbpp_1_1collections_1_1map_1_1_tree_a_v_l_1_1reverse__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a171a248b242eb701a7512426434153be"><td class="memItemLeft" align="right" valign="top"><a id="a171a248b242eb701a7512426434153be" name="a171a248b242eb701a7512426434153be"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>key_type</b> = Key</td></tr>
<tr class="memdesc:a171a248b242eb701a7512426434153be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the keys for the key-value pairs. <br /></td></tr>
<tr class="separator:a171a248b242eb701a7512426434153be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4208b5df75c1bc0af0961a90ac063f4"><td class="memItemLeft" align="right" valign="top"><a id="ad4208b5df75c1bc0af0961a90ac063f4" name="ad4208b5df75c1bc0af0961a90ac063f4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>mapped_type</b> = T</td></tr>
<tr class="memdesc:ad4208b5df75c1bc0af0961a90ac063f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the mapped values for the key-value pairs. <br /></td></tr>
<tr class="separator:ad4208b5df75c1bc0af0961a90ac063f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c9d3419b237d81e0a30f6fa552dfc2"><td class="memItemLeft" align="right" valign="top"><a id="ae3c9d3419b237d81e0a30f6fa552dfc2" name="ae3c9d3419b237d81e0a30f6fa552dfc2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = std::pair&lt; const Key, T &gt;</td></tr>
<tr class="memdesc:ae3c9d3419b237d81e0a30f6fa552dfc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the values stored in the map. <br /></td></tr>
<tr class="separator:ae3c9d3419b237d81e0a30f6fa552dfc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5147fb98de4162b0acdea171b42ed58"><td class="memItemLeft" align="right" valign="top"><a id="af5147fb98de4162b0acdea171b42ed58" name="af5147fb98de4162b0acdea171b42ed58"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = std::size_t</td></tr>
<tr class="memdesc:af5147fb98de4162b0acdea171b42ed58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to calculate sizes. <br /></td></tr>
<tr class="separator:af5147fb98de4162b0acdea171b42ed58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af425e40e7c9b6c0764ad3cd374b38f1e"><td class="memItemLeft" align="right" valign="top"><a id="af425e40e7c9b6c0764ad3cd374b38f1e" name="af425e40e7c9b6c0764ad3cd374b38f1e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b> = std::ptrdiff_t</td></tr>
<tr class="memdesc:af425e40e7c9b6c0764ad3cd374b38f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to calculate differences (unused). <br /></td></tr>
<tr class="separator:af425e40e7c9b6c0764ad3cd374b38f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e807c0f1bc4abcb016cfc2ed6331cf4"><td class="memItemLeft" align="right" valign="top"><a id="a8e807c0f1bc4abcb016cfc2ed6331cf4" name="a8e807c0f1bc4abcb016cfc2ed6331cf4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>key_compare</b> = Compare</td></tr>
<tr class="memdesc:a8e807c0f1bc4abcb016cfc2ed6331cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of compare used in key comparison. <br /></td></tr>
<tr class="separator:a8e807c0f1bc4abcb016cfc2ed6331cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3919b98c06d590058cd30eb81bdfac"><td class="memItemLeft" align="right" valign="top"><a id="a6b3919b98c06d590058cd30eb81bdfac" name="a6b3919b98c06d590058cd30eb81bdfac"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b> = Allocator</td></tr>
<tr class="memdesc:a6b3919b98c06d590058cd30eb81bdfac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of allocator used. <br /></td></tr>
<tr class="separator:a6b3919b98c06d590058cd30eb81bdfac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02417dbef396a816300f4e8f9bd7729"><td class="memItemLeft" align="right" valign="top"><a id="ad02417dbef396a816300f4e8f9bd7729" name="ad02417dbef396a816300f4e8f9bd7729"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b> = <a class="el" href="../../d8/dd6/classbpp_1_1collections_1_1map_1_1_tree_a_v_l.html#ae3c9d3419b237d81e0a30f6fa552dfc2">value_type</a> &amp;</td></tr>
<tr class="memdesc:ad02417dbef396a816300f4e8f9bd7729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of references to values. <br /></td></tr>
<tr class="separator:ad02417dbef396a816300f4e8f9bd7729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ecd04671d25f343e2824378eb8d240b"><td class="memItemLeft" align="right" valign="top"><a id="a7ecd04671d25f343e2824378eb8d240b" name="a7ecd04671d25f343e2824378eb8d240b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b> = const <a class="el" href="../../d8/dd6/classbpp_1_1collections_1_1map_1_1_tree_a_v_l.html#ae3c9d3419b237d81e0a30f6fa552dfc2">value_type</a> &amp;</td></tr>
<tr class="memdesc:a7ecd04671d25f343e2824378eb8d240b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of constant references to values. <br /></td></tr>
<tr class="separator:a7ecd04671d25f343e2824378eb8d240b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a149bf02f625bf3a433a96d7ffe67c028"><td class="memItemLeft" align="right" valign="top"><a id="a149bf02f625bf3a433a96d7ffe67c028" name="a149bf02f625bf3a433a96d7ffe67c028"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>node_type</b> = NodeAVL</td></tr>
<tr class="memdesc:a149bf02f625bf3a433a96d7ffe67c028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of container node. <br /></td></tr>
<tr class="separator:a149bf02f625bf3a433a96d7ffe67c028"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5d599efe1f6a327d9677168d705f07ea"><td class="memItemLeft" align="right" valign="top"><a id="a5d599efe1f6a327d9677168d705f07ea" name="a5d599efe1f6a327d9677168d705f07ea"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TreeAVL</b> ()</td></tr>
<tr class="memdesc:a5d599efe1f6a327d9677168d705f07ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty container. <br /></td></tr>
<tr class="separator:a5d599efe1f6a327d9677168d705f07ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be37d2a846cd0a071068bfe7a39a063"><td class="memItemLeft" align="right" valign="top"><a id="a6be37d2a846cd0a071068bfe7a39a063" name="a6be37d2a846cd0a071068bfe7a39a063"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TreeAVL</b> (const Compare &amp;comp, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:a6be37d2a846cd0a071068bfe7a39a063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty container. Receives the comparison function object to use for all comparisons of keys and the allocator to use for all memory allocations. <br /></td></tr>
<tr class="separator:a6be37d2a846cd0a071068bfe7a39a063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e3221d92e745b6f5a3073027790426"><td class="memItemLeft" align="right" valign="top"><a id="a77e3221d92e745b6f5a3073027790426" name="a77e3221d92e745b6f5a3073027790426"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TreeAVL</b> (const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:a77e3221d92e745b6f5a3073027790426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty container. Receives the allocator to use for all memory allocations. <br /></td></tr>
<tr class="separator:a77e3221d92e745b6f5a3073027790426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaeb232591ec21924b27046814bcef38"><td class="memTemplParams" colspan="2"><a id="abaeb232591ec21924b27046814bcef38" name="abaeb232591ec21924b27046814bcef38"></a>
template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:abaeb232591ec21924b27046814bcef38"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TreeAVL</b> (InputIt first, InputIt last, const Compare &amp;comp=Compare(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:abaeb232591ec21924b27046814bcef38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the range [first, last). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted. Can receive the comparison function object to use for all comparisons of keys and the allocator to use for all memory allocations. <br /></td></tr>
<tr class="separator:abaeb232591ec21924b27046814bcef38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57504ca730a124f9f5bc198a0be7a3b5"><td class="memTemplParams" colspan="2"><a id="a57504ca730a124f9f5bc198a0be7a3b5" name="a57504ca730a124f9f5bc198a0be7a3b5"></a>
template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a57504ca730a124f9f5bc198a0be7a3b5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TreeAVL</b> (InputIt first, InputIt last, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:a57504ca730a124f9f5bc198a0be7a3b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the range [first, last). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted. Receives the allocator to use for all memory allocations. <br /></td></tr>
<tr class="separator:a57504ca730a124f9f5bc198a0be7a3b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db7ba187d29cc4bd552a84773e7e83f"><td class="memItemLeft" align="right" valign="top"><a id="a6db7ba187d29cc4bd552a84773e7e83f" name="a6db7ba187d29cc4bd552a84773e7e83f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TreeAVL</b> (const <a class="el" href="../../d8/dd6/classbpp_1_1collections_1_1map_1_1_tree_a_v_l.html">TreeAVL</a> &amp;other)</td></tr>
<tr class="memdesc:a6db7ba187d29cc4bd552a84773e7e83f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. Constructs the container with the copy of the contents of other. <br /></td></tr>
<tr class="separator:a6db7ba187d29cc4bd552a84773e7e83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4847881cfc3f6d697e4a1aa7c23f275c"><td class="memItemLeft" align="right" valign="top"><a id="a4847881cfc3f6d697e4a1aa7c23f275c" name="a4847881cfc3f6d697e4a1aa7c23f275c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TreeAVL</b> (const <a class="el" href="../../d8/dd6/classbpp_1_1collections_1_1map_1_1_tree_a_v_l.html">TreeAVL</a> &amp;other, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:a4847881cfc3f6d697e4a1aa7c23f275c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. Constructs the container with the copy of the contents of other. Receives the allocator to use for all memory allocations. <br /></td></tr>
<tr class="separator:a4847881cfc3f6d697e4a1aa7c23f275c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4718c5565daf84cc6c8e9bbc445ca3b7"><td class="memItemLeft" align="right" valign="top"><a id="a4718c5565daf84cc6c8e9bbc445ca3b7" name="a4718c5565daf84cc6c8e9bbc445ca3b7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TreeAVL</b> (<a class="el" href="../../d8/dd6/classbpp_1_1collections_1_1map_1_1_tree_a_v_l.html">TreeAVL</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a4718c5565daf84cc6c8e9bbc445ca3b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. Constructs the container with the contents of other using move semantics. After the move, other is guaranteed to be <a class="el" href="../../d8/dd6/classbpp_1_1collections_1_1map_1_1_tree_a_v_l.html#aa5077969fc1cf9f0306190835efe450b" title="Checks if the container has no elements, i.e. whether begin() == end().">empty()</a>. <br /></td></tr>
<tr class="separator:a4718c5565daf84cc6c8e9bbc445ca3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e809a4e629a2da8c7bb4778ceddda1"><td class="memItemLeft" align="right" valign="top"><a id="af3e809a4e629a2da8c7bb4778ceddda1" name="af3e809a4e629a2da8c7bb4778ceddda1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TreeAVL</b> (<a class="el" href="../../d8/dd6/classbpp_1_1collections_1_1map_1_1_tree_a_v_l.html">TreeAVL</a> &amp;&amp;other, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:af3e809a4e629a2da8c7bb4778ceddda1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. Constructs the container with the contents of other using move semantics. After the move, other is guaranteed to be <a class="el" href="../../d8/dd6/classbpp_1_1collections_1_1map_1_1_tree_a_v_l.html#aa5077969fc1cf9f0306190835efe450b" title="Checks if the container has no elements, i.e. whether begin() == end().">empty()</a>. Receives the allocator to use for all memory allocations. <br /></td></tr>
<tr class="separator:af3e809a4e629a2da8c7bb4778ceddda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541892547b247a7765c54a1afa78e5be"><td class="memItemLeft" align="right" valign="top"><a id="a541892547b247a7765c54a1afa78e5be" name="a541892547b247a7765c54a1afa78e5be"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TreeAVL</b> (std::initializer_list&lt; std::pair&lt; const Key, T &gt; &gt; ilist, const Compare &amp;comp=Compare(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:a541892547b247a7765c54a1afa78e5be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the initializer list init. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted. Can receive the comparison function object to use for all comparisons of keys and the allocator to use for all memory allocations. <br /></td></tr>
<tr class="separator:a541892547b247a7765c54a1afa78e5be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403f5875a9be41dfb7b47fabc18b9eb5"><td class="memItemLeft" align="right" valign="top"><a id="a403f5875a9be41dfb7b47fabc18b9eb5" name="a403f5875a9be41dfb7b47fabc18b9eb5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TreeAVL</b> (std::initializer_list&lt; std::pair&lt; const Key, T &gt; &gt; ilist, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:a403f5875a9be41dfb7b47fabc18b9eb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the initializer list init. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted. Receives the allocator to use for all memory allocations. <br /></td></tr>
<tr class="separator:a403f5875a9be41dfb7b47fabc18b9eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab878736cedf6f7b7e609ceb91f45168f"><td class="memItemLeft" align="right" valign="top"><a id="ab878736cedf6f7b7e609ceb91f45168f" name="ab878736cedf6f7b7e609ceb91f45168f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~TreeAVL</b> ()</td></tr>
<tr class="memdesc:ab878736cedf6f7b7e609ceb91f45168f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructs the map. The destructors of the elements are called and the used storage is deallocated. Note, that if the elements are pointers, the pointed-to objects are not destroyed. <br /></td></tr>
<tr class="separator:ab878736cedf6f7b7e609ceb91f45168f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b01be6618480a352ae1b17d52e48d28"><td class="memItemLeft" align="right" valign="top"><a id="a4b01be6618480a352ae1b17d52e48d28" name="a4b01be6618480a352ae1b17d52e48d28"></a>
<a class="el" href="../../d8/dd6/classbpp_1_1collections_1_1map_1_1_tree_a_v_l.html">TreeAVL</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="../../d8/dd6/classbpp_1_1collections_1_1map_1_1_tree_a_v_l.html">TreeAVL</a> &amp;other)</td></tr>
<tr class="memdesc:a4b01be6618480a352ae1b17d52e48d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of other. <br /></td></tr>
<tr class="separator:a4b01be6618480a352ae1b17d52e48d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0e680bf3e438bc3fbaf78163e2b356"><td class="memItemLeft" align="right" valign="top"><a id="abc0e680bf3e438bc3fbaf78163e2b356" name="abc0e680bf3e438bc3fbaf78163e2b356"></a>
<a class="el" href="../../d8/dd6/classbpp_1_1collections_1_1map_1_1_tree_a_v_l.html">TreeAVL</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="../../d8/dd6/classbpp_1_1collections_1_1map_1_1_tree_a_v_l.html">TreeAVL</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:abc0e680bf3e438bc3fbaf78163e2b356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in other is moved from other into this container). After the move, other is in a valid but unspecified state. <br /></td></tr>
<tr class="separator:abc0e680bf3e438bc3fbaf78163e2b356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b6b3773d4c14a60524e559241e922d"><td class="memItemLeft" align="right" valign="top"><a id="ae7b6b3773d4c14a60524e559241e922d" name="ae7b6b3773d4c14a60524e559241e922d"></a>
<a class="el" href="../../d8/dd6/classbpp_1_1collections_1_1map_1_1_tree_a_v_l.html">TreeAVL</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (std::initializer_list&lt; std::pair&lt; const Key, T &gt; &gt; ilist)</td></tr>
<tr class="memdesc:ae7b6b3773d4c14a60524e559241e922d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with those identified by initializer list ilist. <br /></td></tr>
<tr class="separator:ae7b6b3773d4c14a60524e559241e922d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7c7f30803736b66c39c4dcc568e1b9"><td class="memItemLeft" align="right" valign="top"><a id="a9d7c7f30803736b66c39c4dcc568e1b9" name="a9d7c7f30803736b66c39c4dcc568e1b9"></a>
Allocator&#160;</td><td class="memItemRight" valign="bottom"><b>get_allocator</b> () const noexcept</td></tr>
<tr class="memdesc:a9d7c7f30803736b66c39c4dcc568e1b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocator associated with the container. <br /></td></tr>
<tr class="separator:a9d7c7f30803736b66c39c4dcc568e1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b3637802b9dbe8598544c8e3e4c722"><td class="memItemLeft" align="right" valign="top"><a id="a93b3637802b9dbe8598544c8e3e4c722" name="a93b3637802b9dbe8598544c8e3e4c722"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>at</b> (const Key &amp;key) const</td></tr>
<tr class="memdesc:a93b3637802b9dbe8598544c8e3e4c722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the mapped value of the element with key equivalent to key. If no such element exists, an exception of type std::out_of_range is thrown. <br /></td></tr>
<tr class="separator:a93b3637802b9dbe8598544c8e3e4c722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cfd75b1354287e308c875b3221cc37f"><td class="memItemLeft" align="right" valign="top"><a id="a7cfd75b1354287e308c875b3221cc37f" name="a7cfd75b1354287e308c875b3221cc37f"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (const Key &amp;key)</td></tr>
<tr class="memdesc:a7cfd75b1354287e308c875b3221cc37f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the value that is mapped to a key equivalent to key, performing an insertion if such key does not already exist. <br /></td></tr>
<tr class="separator:a7cfd75b1354287e308c875b3221cc37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38bb76d1161a99dff0bf21688a231bb4"><td class="memItemLeft" align="right" valign="top"><a id="a38bb76d1161a99dff0bf21688a231bb4" name="a38bb76d1161a99dff0bf21688a231bb4"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (Key &amp;&amp;key)</td></tr>
<tr class="memdesc:a38bb76d1161a99dff0bf21688a231bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the value that is mapped to a key equivalent to key, performing an insertion if such key does not already exist. <br /></td></tr>
<tr class="separator:a38bb76d1161a99dff0bf21688a231bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dbeef9acd3cc84d55ec378315d3cf3e"><td class="memItemLeft" align="right" valign="top"><a id="a0dbeef9acd3cc84d55ec378315d3cf3e" name="a0dbeef9acd3cc84d55ec378315d3cf3e"></a>
<a class="el" href="../../d8/d33/structbpp_1_1collections_1_1map_1_1_tree_a_v_l_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const noexcept</td></tr>
<tr class="memdesc:a0dbeef9acd3cc84d55ec378315d3cf3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the map. If the map is empty, the returned iterator will be equal to <a class="el" href="../../d8/dd6/classbpp_1_1collections_1_1map_1_1_tree_a_v_l.html#a1c84f5ad3029735ebf63cf0ec1b45417" title="Returns an iterator to the element following the last element of the map. This element acts as a plac...">end()</a>. <br /></td></tr>
<tr class="separator:a0dbeef9acd3cc84d55ec378315d3cf3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c84f5ad3029735ebf63cf0ec1b45417"><td class="memItemLeft" align="right" valign="top"><a id="a1c84f5ad3029735ebf63cf0ec1b45417" name="a1c84f5ad3029735ebf63cf0ec1b45417"></a>
<a class="el" href="../../d8/d33/structbpp_1_1collections_1_1map_1_1_tree_a_v_l_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const noexcept</td></tr>
<tr class="memdesc:a1c84f5ad3029735ebf63cf0ec1b45417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the map. This element acts as a placeholder; attempting to access it results in undefined behavior. <br /></td></tr>
<tr class="separator:a1c84f5ad3029735ebf63cf0ec1b45417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdbaac112d33a723d5b44a2a1c9ceede"><td class="memItemLeft" align="right" valign="top"><a id="abdbaac112d33a723d5b44a2a1c9ceede" name="abdbaac112d33a723d5b44a2a1c9ceede"></a>
<a class="el" href="../../d7/dd0/structbpp_1_1collections_1_1map_1_1_tree_a_v_l_1_1reverse__iterator.html">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rbegin</b> () const noexcept</td></tr>
<tr class="memdesc:abdbaac112d33a723d5b44a2a1c9ceede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed map. It corresponds to the last element of the non-reversed map. If the map is empty, the returned iterator is equal to <a class="el" href="../../d8/dd6/classbpp_1_1collections_1_1map_1_1_tree_a_v_l.html#afa710644dcff03d8197c54732e8d39d0" title="Returns a reverse iterator to the element following the last element of the reversed map....">rend()</a>. <br /></td></tr>
<tr class="separator:abdbaac112d33a723d5b44a2a1c9ceede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa710644dcff03d8197c54732e8d39d0"><td class="memItemLeft" align="right" valign="top"><a id="afa710644dcff03d8197c54732e8d39d0" name="afa710644dcff03d8197c54732e8d39d0"></a>
<a class="el" href="../../d7/dd0/structbpp_1_1collections_1_1map_1_1_tree_a_v_l_1_1reverse__iterator.html">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rend</b> () const noexcept</td></tr>
<tr class="memdesc:afa710644dcff03d8197c54732e8d39d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed map. It corresponds to the element preceding the first element of the non-reversed map. This element acts as a placeholder, attempting to access it results in undefined behavior. <br /></td></tr>
<tr class="separator:afa710644dcff03d8197c54732e8d39d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5077969fc1cf9f0306190835efe450b"><td class="memItemLeft" align="right" valign="top"><a id="aa5077969fc1cf9f0306190835efe450b" name="aa5077969fc1cf9f0306190835efe450b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty</b> () const noexcept</td></tr>
<tr class="memdesc:aa5077969fc1cf9f0306190835efe450b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the container has no elements, i.e. whether <a class="el" href="../../d8/dd6/classbpp_1_1collections_1_1map_1_1_tree_a_v_l.html#a0dbeef9acd3cc84d55ec378315d3cf3e" title="Returns an iterator to the first element of the map. If the map is empty, the returned iterator will ...">begin()</a> == <a class="el" href="../../d8/dd6/classbpp_1_1collections_1_1map_1_1_tree_a_v_l.html#a1c84f5ad3029735ebf63cf0ec1b45417" title="Returns an iterator to the element following the last element of the map. This element acts as a plac...">end()</a>. <br /></td></tr>
<tr class="separator:aa5077969fc1cf9f0306190835efe450b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbcfd4fc2415850180e5dca4c2231388"><td class="memItemLeft" align="right" valign="top"><a id="abbcfd4fc2415850180e5dca4c2231388" name="abbcfd4fc2415850180e5dca4c2231388"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const noexcept</td></tr>
<tr class="memdesc:abbcfd4fc2415850180e5dca4c2231388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the container. <br /></td></tr>
<tr class="separator:abbcfd4fc2415850180e5dca4c2231388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e0e4aaca3e56656f3fec19f32981f2"><td class="memItemLeft" align="right" valign="top"><a id="a85e0e4aaca3e56656f3fec19f32981f2" name="a85e0e4aaca3e56656f3fec19f32981f2"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>memory</b> () const noexcept</td></tr>
<tr class="memdesc:a85e0e4aaca3e56656f3fec19f32981f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total space in memory. <br /></td></tr>
<tr class="separator:a85e0e4aaca3e56656f3fec19f32981f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba6e53a7cd651d2f4a5912e8590232f"><td class="memItemLeft" align="right" valign="top"><a id="adba6e53a7cd651d2f4a5912e8590232f" name="adba6e53a7cd651d2f4a5912e8590232f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> () noexcept</td></tr>
<tr class="memdesc:adba6e53a7cd651d2f4a5912e8590232f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements from the container. After this call, <a class="el" href="../../d8/dd6/classbpp_1_1collections_1_1map_1_1_tree_a_v_l.html#abbcfd4fc2415850180e5dca4c2231388" title="Returns the number of elements in the container.">size()</a> returns zero. Invalidates any references, pointers, or iterators referring to contained elements. Any past-the-end iterator remains valid. <br /></td></tr>
<tr class="separator:adba6e53a7cd651d2f4a5912e8590232f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1504ee7e9d5a838e29c77d3c8c411cd"><td class="memItemLeft" align="right" valign="top"><a id="ab1504ee7e9d5a838e29c77d3c8c411cd" name="ab1504ee7e9d5a838e29c77d3c8c411cd"></a>
std::pair&lt; <a class="el" href="../../d8/d33/structbpp_1_1collections_1_1map_1_1_tree_a_v_l_1_1iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (const std::pair&lt; const Key, T &gt; &amp;value)</td></tr>
<tr class="memdesc:ab1504ee7e9d5a838e29c77d3c8c411cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. Returns a pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool denoting whether the insertion took place. <br /></td></tr>
<tr class="separator:ab1504ee7e9d5a838e29c77d3c8c411cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8cec2062f50b5ff1fb1e38468f6af1"><td class="memItemLeft" align="right" valign="top"><a id="aee8cec2062f50b5ff1fb1e38468f6af1" name="aee8cec2062f50b5ff1fb1e38468f6af1"></a>
std::pair&lt; <a class="el" href="../../d8/d33/structbpp_1_1collections_1_1map_1_1_tree_a_v_l_1_1iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (std::pair&lt; const Key, T &gt; &amp;&amp;value)</td></tr>
<tr class="memdesc:aee8cec2062f50b5ff1fb1e38468f6af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. Returns a pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool denoting whether the insertion took place. <br /></td></tr>
<tr class="separator:aee8cec2062f50b5ff1fb1e38468f6af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3e93b69ebf170d111dcc438a0c2550"><td class="memItemLeft" align="right" valign="top"><a id="a8a3e93b69ebf170d111dcc438a0c2550" name="a8a3e93b69ebf170d111dcc438a0c2550"></a>
<a class="el" href="../../d8/d33/structbpp_1_1collections_1_1map_1_1_tree_a_v_l_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (<a class="el" href="../../d8/d33/structbpp_1_1collections_1_1map_1_1_tree_a_v_l_1_1iterator.html">iterator</a> hint, const std::pair&lt; const Key, T &gt; &amp;value)</td></tr>
<tr class="memdesc:a8a3e93b69ebf170d111dcc438a0c2550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts value in the position as close as possible to hint. Returns an iterator to the inserted element, or to the element that prevented the insertion. <br /></td></tr>
<tr class="separator:a8a3e93b69ebf170d111dcc438a0c2550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e20fa26c959f493cebc49038f9c113"><td class="memItemLeft" align="right" valign="top"><a id="a17e20fa26c959f493cebc49038f9c113" name="a17e20fa26c959f493cebc49038f9c113"></a>
<a class="el" href="../../d8/d33/structbpp_1_1collections_1_1map_1_1_tree_a_v_l_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (<a class="el" href="../../d8/d33/structbpp_1_1collections_1_1map_1_1_tree_a_v_l_1_1iterator.html">iterator</a> hint, std::pair&lt; const Key, T &gt; &amp;&amp;value)</td></tr>
<tr class="memdesc:a17e20fa26c959f493cebc49038f9c113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts value in the position as close as possible to hint. Returns an iterator to the inserted element, or to the element that prevented the insertion. <br /></td></tr>
<tr class="separator:a17e20fa26c959f493cebc49038f9c113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85dd631620a6f25c240864f3491660ff"><td class="memTemplParams" colspan="2"><a id="a85dd631620a6f25c240864f3491660ff" name="a85dd631620a6f25c240864f3491660ff"></a>
template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a85dd631620a6f25c240864f3491660ff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert</b> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a85dd631620a6f25c240864f3491660ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from range [first, last). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted. <br /></td></tr>
<tr class="separator:a85dd631620a6f25c240864f3491660ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad396ed0221e8ec2abafbb20ec546cb85"><td class="memItemLeft" align="right" valign="top"><a id="ad396ed0221e8ec2abafbb20ec546cb85" name="ad396ed0221e8ec2abafbb20ec546cb85"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (std::initializer_list&lt; std::pair&lt; const Key, T &gt; &gt; ilist)</td></tr>
<tr class="memdesc:ad396ed0221e8ec2abafbb20ec546cb85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from initializer list ilist. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted. <br /></td></tr>
<tr class="separator:ad396ed0221e8ec2abafbb20ec546cb85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4bf1ecf4be6274cc4e0ddc706e3fca"><td class="memTemplParams" colspan="2"><a id="a1f4bf1ecf4be6274cc4e0ddc706e3fca" name="a1f4bf1ecf4be6274cc4e0ddc706e3fca"></a>
template&lt;class M &gt; </td></tr>
<tr class="memitem:a1f4bf1ecf4be6274cc4e0ddc706e3fca"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="../../d8/d33/structbpp_1_1collections_1_1map_1_1_tree_a_v_l_1_1iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_or_assign</b> (const Key &amp;k, M &amp;&amp;obj)</td></tr>
<tr class="memdesc:a1f4bf1ecf4be6274cc4e0ddc706e3fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a key equivalent to k already exists in the container, assigns obj to the mapped_type corresponding to the key k. If the key does not exist, inserts the new value as if by insert. <br /></td></tr>
<tr class="separator:a1f4bf1ecf4be6274cc4e0ddc706e3fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc4cee933350e19a50b098b6b45bf7e"><td class="memTemplParams" colspan="2"><a id="a8bc4cee933350e19a50b098b6b45bf7e" name="a8bc4cee933350e19a50b098b6b45bf7e"></a>
template&lt;class M &gt; </td></tr>
<tr class="memitem:a8bc4cee933350e19a50b098b6b45bf7e"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="../../d8/d33/structbpp_1_1collections_1_1map_1_1_tree_a_v_l_1_1iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_or_assign</b> (Key &amp;&amp;k, M &amp;&amp;obj)</td></tr>
<tr class="memdesc:a8bc4cee933350e19a50b098b6b45bf7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a key equivalent to k already exists in the container, assigns obj to the mapped_type corresponding to the key k. If the key does not exist, inserts the new value as if by insert. <br /></td></tr>
<tr class="separator:a8bc4cee933350e19a50b098b6b45bf7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d839a4c801dc643c75daf0a1571820"><td class="memTemplParams" colspan="2"><a id="aa5d839a4c801dc643c75daf0a1571820" name="aa5d839a4c801dc643c75daf0a1571820"></a>
template&lt;class M &gt; </td></tr>
<tr class="memitem:aa5d839a4c801dc643c75daf0a1571820"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="../../d8/d33/structbpp_1_1collections_1_1map_1_1_tree_a_v_l_1_1iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_or_assign</b> (<a class="el" href="../../d8/d33/structbpp_1_1collections_1_1map_1_1_tree_a_v_l_1_1iterator.html">iterator</a> hint, const Key &amp;k, M &amp;&amp;obj)</td></tr>
<tr class="memdesc:aa5d839a4c801dc643c75daf0a1571820"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a key equivalent to k already exists in the container, assigns obj to the mapped_type corresponding to the key k. If the key does not exist, inserts the new value as if by insert. <br /></td></tr>
<tr class="separator:aa5d839a4c801dc643c75daf0a1571820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb87424e2946c3ddc7d60de6969b790e"><td class="memTemplParams" colspan="2"><a id="acb87424e2946c3ddc7d60de6969b790e" name="acb87424e2946c3ddc7d60de6969b790e"></a>
template&lt;class M &gt; </td></tr>
<tr class="memitem:acb87424e2946c3ddc7d60de6969b790e"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="../../d8/d33/structbpp_1_1collections_1_1map_1_1_tree_a_v_l_1_1iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_or_assign</b> (<a class="el" href="../../d8/d33/structbpp_1_1collections_1_1map_1_1_tree_a_v_l_1_1iterator.html">iterator</a> hint, Key &amp;&amp;k, M &amp;&amp;obj)</td></tr>
<tr class="memdesc:acb87424e2946c3ddc7d60de6969b790e"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a key equivalent to k already exists in the container, assigns obj to the mapped_type corresponding to the key k. If the key does not exist, inserts the new value as if by insert. <br /></td></tr>
<tr class="separator:acb87424e2946c3ddc7d60de6969b790e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a007091e94b9bb9e776f52a2456cb35c7"><td class="memItemLeft" align="right" valign="top"><a id="a007091e94b9bb9e776f52a2456cb35c7" name="a007091e94b9bb9e776f52a2456cb35c7"></a>
<a class="el" href="../../d8/d33/structbpp_1_1collections_1_1map_1_1_tree_a_v_l_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (<a class="el" href="../../d8/d33/structbpp_1_1collections_1_1map_1_1_tree_a_v_l_1_1iterator.html">iterator</a> pos)</td></tr>
<tr class="memdesc:a007091e94b9bb9e776f52a2456cb35c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes element at pos from the container. Returns iterator following the last removed element. <br /></td></tr>
<tr class="separator:a007091e94b9bb9e776f52a2456cb35c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa246ff5d6c4cd14d41270de33918ddfc"><td class="memItemLeft" align="right" valign="top"><a id="aa246ff5d6c4cd14d41270de33918ddfc" name="aa246ff5d6c4cd14d41270de33918ddfc"></a>
<a class="el" href="../../d8/d33/structbpp_1_1collections_1_1map_1_1_tree_a_v_l_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (<a class="el" href="../../d8/d33/structbpp_1_1collections_1_1map_1_1_tree_a_v_l_1_1iterator.html">iterator</a> first, <a class="el" href="../../d8/d33/structbpp_1_1collections_1_1map_1_1_tree_a_v_l_1_1iterator.html">iterator</a> last)</td></tr>
<tr class="memdesc:aa246ff5d6c4cd14d41270de33918ddfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the elements in the range [first; last), which must be a valid range in *this. <br /></td></tr>
<tr class="separator:aa246ff5d6c4cd14d41270de33918ddfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429bd4c9df9c275b02aa5cabff9b6769"><td class="memItemLeft" align="right" valign="top"><a id="a429bd4c9df9c275b02aa5cabff9b6769" name="a429bd4c9df9c275b02aa5cabff9b6769"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (const Key &amp;key)</td></tr>
<tr class="memdesc:a429bd4c9df9c275b02aa5cabff9b6769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element (if one exists) with the key equivalent to key. Returns the number of elements removed (0 or 1). <br /></td></tr>
<tr class="separator:a429bd4c9df9c275b02aa5cabff9b6769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a7daef9d20d0ca0ce9f0a08227a39a"><td class="memTemplParams" colspan="2"><a id="a48a7daef9d20d0ca0ce9f0a08227a39a" name="a48a7daef9d20d0ca0ce9f0a08227a39a"></a>
template&lt;class K &gt; </td></tr>
<tr class="memitem:a48a7daef9d20d0ca0ce9f0a08227a39a"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>erase</b> (K &amp;&amp;key)</td></tr>
<tr class="memdesc:a48a7daef9d20d0ca0ce9f0a08227a39a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element (if one exists) with the key equivalent to key. Returns the number of elements removed (0 or 1). <br /></td></tr>
<tr class="separator:a48a7daef9d20d0ca0ce9f0a08227a39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c7a4d2338d0cbb9e0af00f46ec0afd"><td class="memTemplParams" colspan="2"><a id="af0c7a4d2338d0cbb9e0af00f46ec0afd" name="af0c7a4d2338d0cbb9e0af00f46ec0afd"></a>
template&lt;class K &gt; </td></tr>
<tr class="memitem:af0c7a4d2338d0cbb9e0af00f46ec0afd"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>count</b> (const K &amp;key) const</td></tr>
<tr class="memdesc:af0c7a4d2338d0cbb9e0af00f46ec0afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements with key that compares equivalent to the specified argument, which is either 1 or 0 since this container does not allow duplicates. <br /></td></tr>
<tr class="separator:af0c7a4d2338d0cbb9e0af00f46ec0afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6306865b23cac2f8d98167419052cd4"><td class="memTemplParams" colspan="2"><a id="ac6306865b23cac2f8d98167419052cd4" name="ac6306865b23cac2f8d98167419052cd4"></a>
template&lt;class K &gt; </td></tr>
<tr class="memitem:ac6306865b23cac2f8d98167419052cd4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/d33/structbpp_1_1collections_1_1map_1_1_tree_a_v_l_1_1iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find</b> (const K &amp;key)</td></tr>
<tr class="memdesc:ac6306865b23cac2f8d98167419052cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equivalent to key and returns an iterator to the element. If no such element is found, past-the-end (see <a class="el" href="../../d8/dd6/classbpp_1_1collections_1_1map_1_1_tree_a_v_l.html#a1c84f5ad3029735ebf63cf0ec1b45417" title="Returns an iterator to the element following the last element of the map. This element acts as a plac...">end()</a>) iterator is returned. <br /></td></tr>
<tr class="separator:ac6306865b23cac2f8d98167419052cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4756de318c381ba54d9510687af19c49"><td class="memTemplParams" colspan="2"><a id="a4756de318c381ba54d9510687af19c49" name="a4756de318c381ba54d9510687af19c49"></a>
template&lt;class K &gt; </td></tr>
<tr class="memitem:a4756de318c381ba54d9510687af19c49"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>contains</b> (const K &amp;key) const</td></tr>
<tr class="memdesc:a4756de318c381ba54d9510687af19c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there is an element with key that compares equivalent to the value x. <br /></td></tr>
<tr class="separator:a4756de318c381ba54d9510687af19c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3072fd365811509440ed83d0ca71ad9"><td class="memTemplParams" colspan="2"><a id="ab3072fd365811509440ed83d0ca71ad9" name="ab3072fd365811509440ed83d0ca71ad9"></a>
template&lt;class K &gt; </td></tr>
<tr class="memitem:ab3072fd365811509440ed83d0ca71ad9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/d33/structbpp_1_1collections_1_1map_1_1_tree_a_v_l_1_1iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>lower_bound</b> (const K &amp;key)</td></tr>
<tr class="memdesc:ab3072fd365811509440ed83d0ca71ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that compares not less (i.e. greater or equal) to the value x. <br /></td></tr>
<tr class="separator:ab3072fd365811509440ed83d0ca71ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c507559c69a4c3cc0d54c64f7e58f8"><td class="memTemplParams" colspan="2"><a id="a29c507559c69a4c3cc0d54c64f7e58f8" name="a29c507559c69a4c3cc0d54c64f7e58f8"></a>
template&lt;class K &gt; </td></tr>
<tr class="memitem:a29c507559c69a4c3cc0d54c64f7e58f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/d33/structbpp_1_1collections_1_1map_1_1_tree_a_v_l_1_1iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>upper_bound</b> (const K &amp;key)</td></tr>
<tr class="memdesc:a29c507559c69a4c3cc0d54c64f7e58f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that compares greater to the value x. <br /></td></tr>
<tr class="separator:a29c507559c69a4c3cc0d54c64f7e58f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec2d977025285adeb6f4b000edcb5c8"><td class="memTemplParams" colspan="2"><a id="a2ec2d977025285adeb6f4b000edcb5c8" name="a2ec2d977025285adeb6f4b000edcb5c8"></a>
template&lt;class K &gt; </td></tr>
<tr class="memitem:a2ec2d977025285adeb6f4b000edcb5c8"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="../../d8/d33/structbpp_1_1collections_1_1map_1_1_tree_a_v_l_1_1iterator.html">iterator</a>, <a class="el" href="../../d8/d33/structbpp_1_1collections_1_1map_1_1_tree_a_v_l_1_1iterator.html">iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>equal_range</b> (const K &amp;key)</td></tr>
<tr class="memdesc:a2ec2d977025285adeb6f4b000edcb5c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="../../d8/dd6/classbpp_1_1collections_1_1map_1_1_tree_a_v_l.html#ab3072fd365811509440ed83d0ca71ad9" title="Returns an iterator pointing to the first element that compares not less (i.e. greater or equal) to t...">lower_bound()</a>, and the second with <a class="el" href="../../d8/dd6/classbpp_1_1collections_1_1map_1_1_tree_a_v_l.html#a29c507559c69a4c3cc0d54c64f7e58f8" title="Returns an iterator pointing to the first element that compares greater to the value x.">upper_bound()</a>. <br /></td></tr>
<tr class="separator:a2ec2d977025285adeb6f4b000edcb5c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a6b280f5a0fc6c28d5fc1c182f34ecd1f"><td class="memTemplParams" colspan="2"><a id="a6b280f5a0fc6c28d5fc1c182f34ecd1f" name="a6b280f5a0fc6c28d5fc1c182f34ecd1f"></a>
template&lt;class A , class B , class C , class D &gt; </td></tr>
<tr class="memitem:a6b280f5a0fc6c28d5fc1c182f34ecd1f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d8/dd6/classbpp_1_1collections_1_1map_1_1_tree_a_v_l.html">TreeAVL</a>&lt; A, B, C, D &gt; &amp;lhs, const <a class="el" href="../../d8/dd6/classbpp_1_1collections_1_1map_1_1_tree_a_v_l.html">TreeAVL</a>&lt; A, B, C, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a6b280f5a0fc6c28d5fc1c182f34ecd1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the contents of lhs and rhs are equal, that is, they have the same number of elements and each element in lhs compares equal with the element in rhs at the same position. <br /></td></tr>
<tr class="separator:a6b280f5a0fc6c28d5fc1c182f34ecd1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbde3aab88ccc3d13f15f43dc4004e0b"><td class="memTemplParams" colspan="2"><a id="afbde3aab88ccc3d13f15f43dc4004e0b" name="afbde3aab88ccc3d13f15f43dc4004e0b"></a>
template&lt;class A , class B , class C , class D &gt; </td></tr>
<tr class="memitem:afbde3aab88ccc3d13f15f43dc4004e0b"><td class="memTemplItemLeft" align="right" valign="top">std::strong_ordering&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=&gt;</b> (const <a class="el" href="../../d8/dd6/classbpp_1_1collections_1_1map_1_1_tree_a_v_l.html">TreeAVL</a>&lt; A, B, C, D &gt; &amp;lhs, const <a class="el" href="../../d8/dd6/classbpp_1_1collections_1_1map_1_1_tree_a_v_l.html">TreeAVL</a>&lt; A, B, C, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:afbde3aab88ccc3d13f15f43dc4004e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of lhs and rhs lexicographically. <br /></td></tr>
<tr class="separator:afbde3aab88ccc3d13f15f43dc4004e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc77e660abdf9b90a498705b5280110"><td class="memTemplParams" colspan="2"><a id="a4cc77e660abdf9b90a498705b5280110" name="a4cc77e660abdf9b90a498705b5280110"></a>
template&lt;class A , class B , class C , class D , class Pred &gt; </td></tr>
<tr class="memitem:a4cc77e660abdf9b90a498705b5280110"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::erase_if</b> (<a class="el" href="../../d8/dd6/classbpp_1_1collections_1_1map_1_1_tree_a_v_l.html">TreeAVL</a>&lt; A, B, C, D &gt; &amp;tree, Pred pred)</td></tr>
<tr class="memdesc:a4cc77e660abdf9b90a498705b5280110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements that satisfy the predicate pred from the container. <br /></td></tr>
<tr class="separator:a4cc77e660abdf9b90a498705b5280110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c654f9e5ab05c76129ff66a3c0dca83"><td class="memTemplParams" colspan="2"><a id="a2c654f9e5ab05c76129ff66a3c0dca83" name="a2c654f9e5ab05c76129ff66a3c0dca83"></a>
template&lt;class A , class B , class C , class D &gt; </td></tr>
<tr class="memitem:a2c654f9e5ab05c76129ff66a3c0dca83"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::swap</b> (<a class="el" href="../../d8/dd6/classbpp_1_1collections_1_1map_1_1_tree_a_v_l.html">TreeAVL</a>&lt; A, B, C, D &gt; &amp;lhs, <a class="el" href="../../d8/dd6/classbpp_1_1collections_1_1map_1_1_tree_a_v_l.html">TreeAVL</a>&lt; A, B, C, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a2c654f9e5ab05c76129ff66a3c0dca83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized swapping function. <br /></td></tr>
<tr class="separator:a2c654f9e5ab05c76129ff66a3c0dca83"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class Key, class T, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;<br />
class bpp::collections::map::TreeAVL&lt; Key, T, Compare, Allocator &gt;</div><p ><a class="el" href="../../d8/dd6/classbpp_1_1collections_1_1map_1_1_tree_a_v_l.html" title="TreeAVL is a sorted associative container that contains key-value pairs with unique keys....">TreeAVL</a> is a sorted associative container that contains key-value pairs with unique keys. Keys are sorted by using the comparison function Compare. Search, removal, and insertion operations have logarithmic complexity. This is an implementation of an Adelson-Velsky and Landis Tree. </p>
</div><hr/>The documentation for this class was generated from the following file:<ul>
<li>Collections/<a class="el" href="../../db/d18/_tree_a_v_l_8h_source.html">TreeAVL.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
