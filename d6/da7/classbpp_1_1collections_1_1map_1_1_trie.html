<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>B++ Library: bpp::collections::map::Trie&lt; Key, T, Container, Allocator &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">B++ Library
   </div>
   <div id="projectbrief">A general purpose C++ library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d3/dd4/namespacebpp.html">bpp</a></li><li class="navelem"><a class="el" href="../../d0/d04/namespacebpp_1_1collections.html">collections</a></li><li class="navelem"><a class="el" href="../../d3/d6c/namespacebpp_1_1collections_1_1map.html">map</a></li><li class="navelem"><a class="el" href="../../d6/da7/classbpp_1_1collections_1_1map_1_1_trie.html">Trie</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle"><div class="title">bpp::collections::map::Trie&lt; Key, T, Container, Allocator &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="../../d6/da7/classbpp_1_1collections_1_1map_1_1_trie.html" title="Trie is a sorted associative container that contains key-value pairs with unique keys....">Trie</a> is a sorted associative container that contains key-value pairs with unique keys. Any indexed collection can be used as key for the <a class="el" href="../../d6/da7/classbpp_1_1collections_1_1map_1_1_trie.html" title="Trie is a sorted associative container that contains key-value pairs with unique keys....">Trie</a>, but the base type should be specified. The Container support class can be specified but by default std::map is used. Keys are sorted by using the comparison function within Container. Search, removal, and insertion operations have loglinear complexity. This is an implementation of a trie/prefix tree structure.  
 <a href="../../d6/da7/classbpp_1_1collections_1_1map_1_1_trie.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../db/d43/_trie_8h_source.html">Trie.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d83/structbpp_1_1collections_1_1map_1_1_trie_1_1const__iterator.html">const_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d9/d83/structbpp_1_1collections_1_1map_1_1_trie_1_1const__iterator.html" title="const_iterator is an object that allows iteration of the container in the order of the sorted keys fo...">const_iterator</a> is an object that allows iteration of the container in the order of the sorted keys for access only. Beware that any changes in the tree may invalidate the iterators and produce undefined behaviour.  <a href="../../d9/d83/structbpp_1_1collections_1_1map_1_1_trie_1_1const__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d04/structbpp_1_1collections_1_1map_1_1_trie_1_1const__reverse__iterator.html">const_reverse_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d3/d04/structbpp_1_1collections_1_1map_1_1_trie_1_1const__reverse__iterator.html" title="const_reverse_iterator is an object that allows iteration of the container in the inverse order of th...">const_reverse_iterator</a> is an object that allows iteration of the container in the inverse order of the sorted keys for access only. Beware that any changes in the tree may invalidate the iterators and produce undefined behaviour.  <a href="../../d3/d04/structbpp_1_1collections_1_1map_1_1_trie_1_1const__reverse__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/deb/structbpp_1_1collections_1_1map_1_1_trie_1_1iterator.html">iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterator is an object that allows iteration of the container in the order of the sorted keys. Beware that any changes in the trie may invalidate the iterators and produce undefined behaviour.  <a href="../../d1/deb/structbpp_1_1collections_1_1map_1_1_trie_1_1iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dc5/structbpp_1_1collections_1_1map_1_1_trie_1_1reverse__iterator.html">reverse_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d3/dc5/structbpp_1_1collections_1_1map_1_1_trie_1_1reverse__iterator.html" title="reverse_iterator is an object that allows iteration of the container in the inverse order of the sort...">reverse_iterator</a> is an object that allows iteration of the container in the inverse order of the sorted keys. Beware that any changes in the trie may invalidate the iterators and produce undefined behaviour.  <a href="../../d3/dc5/structbpp_1_1collections_1_1map_1_1_trie_1_1reverse__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1576435bfdb148a48290f00585d36697"><td class="memItemLeft" align="right" valign="top"><a id="a1576435bfdb148a48290f00585d36697" name="a1576435bfdb148a48290f00585d36697"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>key_type</b> = std::vector&lt; Key &gt;</td></tr>
<tr class="memdesc:a1576435bfdb148a48290f00585d36697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the keys for the key-value pairs. <br /></td></tr>
<tr class="separator:a1576435bfdb148a48290f00585d36697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32235dc581921795f054d9e12569c583"><td class="memItemLeft" align="right" valign="top"><a id="a32235dc581921795f054d9e12569c583" name="a32235dc581921795f054d9e12569c583"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>mapped_type</b> = T</td></tr>
<tr class="memdesc:a32235dc581921795f054d9e12569c583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the mapped values for the key-value pairs. <br /></td></tr>
<tr class="separator:a32235dc581921795f054d9e12569c583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc534af247d1bd74ea47e260c19da31"><td class="memItemLeft" align="right" valign="top"><a id="a8fc534af247d1bd74ea47e260c19da31" name="a8fc534af247d1bd74ea47e260c19da31"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = std::pair&lt; const std::vector&lt; Key &gt;, T &gt;</td></tr>
<tr class="memdesc:a8fc534af247d1bd74ea47e260c19da31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the values stored in the map. <br /></td></tr>
<tr class="separator:a8fc534af247d1bd74ea47e260c19da31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67fd3e3ced6f87f71d577720aef10493"><td class="memItemLeft" align="right" valign="top"><a id="a67fd3e3ced6f87f71d577720aef10493" name="a67fd3e3ced6f87f71d577720aef10493"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = std::size_t</td></tr>
<tr class="memdesc:a67fd3e3ced6f87f71d577720aef10493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to calculate sizes. <br /></td></tr>
<tr class="separator:a67fd3e3ced6f87f71d577720aef10493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1dc7d0b11dc2603f4687573a90c3ff3"><td class="memItemLeft" align="right" valign="top"><a id="ae1dc7d0b11dc2603f4687573a90c3ff3" name="ae1dc7d0b11dc2603f4687573a90c3ff3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b> = std::ptrdiff_t</td></tr>
<tr class="memdesc:ae1dc7d0b11dc2603f4687573a90c3ff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to calculate differences (unused). <br /></td></tr>
<tr class="separator:ae1dc7d0b11dc2603f4687573a90c3ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225aa2e9edcbd26fb87c241983f59dda"><td class="memItemLeft" align="right" valign="top"><a id="a225aa2e9edcbd26fb87c241983f59dda" name="a225aa2e9edcbd26fb87c241983f59dda"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b> = Allocator</td></tr>
<tr class="memdesc:a225aa2e9edcbd26fb87c241983f59dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of allocator used. <br /></td></tr>
<tr class="separator:a225aa2e9edcbd26fb87c241983f59dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88414db4c40041799cfbe32f1c520b1b"><td class="memItemLeft" align="right" valign="top"><a id="a88414db4c40041799cfbe32f1c520b1b" name="a88414db4c40041799cfbe32f1c520b1b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b> = <a class="el" href="../../d6/da7/classbpp_1_1collections_1_1map_1_1_trie.html#a8fc534af247d1bd74ea47e260c19da31">value_type</a> &amp;</td></tr>
<tr class="memdesc:a88414db4c40041799cfbe32f1c520b1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of references to values. <br /></td></tr>
<tr class="separator:a88414db4c40041799cfbe32f1c520b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a9b941e41d4d50db2f527ad663e950"><td class="memItemLeft" align="right" valign="top"><a id="ac9a9b941e41d4d50db2f527ad663e950" name="ac9a9b941e41d4d50db2f527ad663e950"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b> = const <a class="el" href="../../d6/da7/classbpp_1_1collections_1_1map_1_1_trie.html#a8fc534af247d1bd74ea47e260c19da31">value_type</a> &amp;</td></tr>
<tr class="memdesc:ac9a9b941e41d4d50db2f527ad663e950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of constant references to values;. <br /></td></tr>
<tr class="separator:ac9a9b941e41d4d50db2f527ad663e950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b1576212a6fb21d4519d75427027cf"><td class="memItemLeft" align="right" valign="top"><a id="a96b1576212a6fb21d4519d75427027cf" name="a96b1576212a6fb21d4519d75427027cf"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>node_type</b> = NodeTrie</td></tr>
<tr class="memdesc:a96b1576212a6fb21d4519d75427027cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of container node. <br /></td></tr>
<tr class="separator:a96b1576212a6fb21d4519d75427027cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e87fcc466a6fa1fdc658caf519cc3d"><td class="memItemLeft" align="right" valign="top"><a id="a66e87fcc466a6fa1fdc658caf519cc3d" name="a66e87fcc466a6fa1fdc658caf519cc3d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>container_type</b> = Container</td></tr>
<tr class="memdesc:a66e87fcc466a6fa1fdc658caf519cc3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of container. <br /></td></tr>
<tr class="separator:a66e87fcc466a6fa1fdc658caf519cc3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac85d2714c8359dbdd43aca219b8bc59b"><td class="memItemLeft" align="right" valign="top"><a id="ac85d2714c8359dbdd43aca219b8bc59b" name="ac85d2714c8359dbdd43aca219b8bc59b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Trie</b> ()</td></tr>
<tr class="memdesc:ac85d2714c8359dbdd43aca219b8bc59b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty container. <br /></td></tr>
<tr class="separator:ac85d2714c8359dbdd43aca219b8bc59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc539987acd642ad3f4579086afab330"><td class="memItemLeft" align="right" valign="top"><a id="adc539987acd642ad3f4579086afab330" name="adc539987acd642ad3f4579086afab330"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Trie</b> (const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:adc539987acd642ad3f4579086afab330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty container. Receives the allocator to use for all memory allocations. <br /></td></tr>
<tr class="separator:adc539987acd642ad3f4579086afab330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a1702834724fb231056173c7c213d85"><td class="memTemplParams" colspan="2"><a id="a5a1702834724fb231056173c7c213d85" name="a5a1702834724fb231056173c7c213d85"></a>
template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a5a1702834724fb231056173c7c213d85"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Trie</b> (InputIt first, InputIt last, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:a5a1702834724fb231056173c7c213d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the range [first, last). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted. Receives the allocator to use for all memory allocations. <br /></td></tr>
<tr class="separator:a5a1702834724fb231056173c7c213d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ceede4c66ccd032dfcdcb2566824fae"><td class="memItemLeft" align="right" valign="top"><a id="a7ceede4c66ccd032dfcdcb2566824fae" name="a7ceede4c66ccd032dfcdcb2566824fae"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Trie</b> (const <a class="el" href="../../d6/da7/classbpp_1_1collections_1_1map_1_1_trie.html">Trie</a> &amp;other, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:a7ceede4c66ccd032dfcdcb2566824fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. Constructs the container with the copy of the contents of other. Can receive the allocator to use for all memory allocations. <br /></td></tr>
<tr class="separator:a7ceede4c66ccd032dfcdcb2566824fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29beb118d75b9bf64a2e0a7268c51fd2"><td class="memItemLeft" align="right" valign="top"><a id="a29beb118d75b9bf64a2e0a7268c51fd2" name="a29beb118d75b9bf64a2e0a7268c51fd2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Trie</b> (<a class="el" href="../../d6/da7/classbpp_1_1collections_1_1map_1_1_trie.html">Trie</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a29beb118d75b9bf64a2e0a7268c51fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. Constructs the container with the contents of other using move semantics. After the move, other is guaranteed to be <a class="el" href="../../d6/da7/classbpp_1_1collections_1_1map_1_1_trie.html#a45f2bc041b36c00f2306428448af5a73" title="Checks if the container has no elements, i.e. whether begin() == end().">empty()</a>. <br /></td></tr>
<tr class="separator:a29beb118d75b9bf64a2e0a7268c51fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53dc1c62fef535046df024e1ec08e101"><td class="memItemLeft" align="right" valign="top"><a id="a53dc1c62fef535046df024e1ec08e101" name="a53dc1c62fef535046df024e1ec08e101"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Trie</b> (<a class="el" href="../../d6/da7/classbpp_1_1collections_1_1map_1_1_trie.html">Trie</a> &amp;&amp;other, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:a53dc1c62fef535046df024e1ec08e101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. Constructs the container with the contents of other using move semantics. After the move, other is guaranteed to be <a class="el" href="../../d6/da7/classbpp_1_1collections_1_1map_1_1_trie.html#a45f2bc041b36c00f2306428448af5a73" title="Checks if the container has no elements, i.e. whether begin() == end().">empty()</a>. Receives the allocator to use for all memory allocations. <br /></td></tr>
<tr class="separator:a53dc1c62fef535046df024e1ec08e101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28c445c0736b42c35ceb5793f2a5e4c8"><td class="memTemplParams" colspan="2"><a id="a28c445c0736b42c35ceb5793f2a5e4c8" name="a28c445c0736b42c35ceb5793f2a5e4c8"></a>
template&lt;class Vector &gt; </td></tr>
<tr class="memitem:a28c445c0736b42c35ceb5793f2a5e4c8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Trie</b> (std::initializer_list&lt; std::pair&lt; const Vector, T &gt; &gt; ilist, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:a28c445c0736b42c35ceb5793f2a5e4c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the initializer list init. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted. Can receive the allocator to use for all memory allocations. <br /></td></tr>
<tr class="separator:a28c445c0736b42c35ceb5793f2a5e4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27bdb98ece9160500e30a9ee337a6566"><td class="memItemLeft" align="right" valign="top"><a id="a27bdb98ece9160500e30a9ee337a6566" name="a27bdb98ece9160500e30a9ee337a6566"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~Trie</b> ()</td></tr>
<tr class="memdesc:a27bdb98ece9160500e30a9ee337a6566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructs the map. The destructors of the elements are called and the used storage is deallocated. Note, that if the elements are pointers, the pointed-to objects are not destroyed. <br /></td></tr>
<tr class="separator:a27bdb98ece9160500e30a9ee337a6566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ad3b6f1827feea5ff26a72886f43ed"><td class="memItemLeft" align="right" valign="top"><a id="a67ad3b6f1827feea5ff26a72886f43ed" name="a67ad3b6f1827feea5ff26a72886f43ed"></a>
<a class="el" href="../../d6/da7/classbpp_1_1collections_1_1map_1_1_trie.html">Trie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="../../d6/da7/classbpp_1_1collections_1_1map_1_1_trie.html">Trie</a> &amp;other)</td></tr>
<tr class="memdesc:a67ad3b6f1827feea5ff26a72886f43ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of other. <br /></td></tr>
<tr class="separator:a67ad3b6f1827feea5ff26a72886f43ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac466e127d13ad33ef728abe289c9f783"><td class="memItemLeft" align="right" valign="top"><a id="ac466e127d13ad33ef728abe289c9f783" name="ac466e127d13ad33ef728abe289c9f783"></a>
<a class="el" href="../../d6/da7/classbpp_1_1collections_1_1map_1_1_trie.html">Trie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="../../d6/da7/classbpp_1_1collections_1_1map_1_1_trie.html">Trie</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:ac466e127d13ad33ef728abe289c9f783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in other is moved from other into this container). After the move, other is in a valid but unspecified state. <br /></td></tr>
<tr class="separator:ac466e127d13ad33ef728abe289c9f783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c60ab5321e65e21dcca4dd9927e2cca"><td class="memTemplParams" colspan="2"><a id="a0c60ab5321e65e21dcca4dd9927e2cca" name="a0c60ab5321e65e21dcca4dd9927e2cca"></a>
template&lt;class Vector &gt; </td></tr>
<tr class="memitem:a0c60ab5321e65e21dcca4dd9927e2cca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/da7/classbpp_1_1collections_1_1map_1_1_trie.html">Trie</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (std::initializer_list&lt; std::pair&lt; const Vector, T &gt; &gt; ilist)</td></tr>
<tr class="memdesc:a0c60ab5321e65e21dcca4dd9927e2cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with those identified by initializer list ilist. <br /></td></tr>
<tr class="separator:a0c60ab5321e65e21dcca4dd9927e2cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd82c018f31167079b014697253e9ca"><td class="memItemLeft" align="right" valign="top"><a id="a2dd82c018f31167079b014697253e9ca" name="a2dd82c018f31167079b014697253e9ca"></a>
Allocator&#160;</td><td class="memItemRight" valign="bottom"><b>get_allocator</b> () const noexcept</td></tr>
<tr class="memdesc:a2dd82c018f31167079b014697253e9ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocator associated with the container. <br /></td></tr>
<tr class="separator:a2dd82c018f31167079b014697253e9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4147f6c8cbcc7f07c8c968176e5c6d"><td class="memTemplParams" colspan="2"><a id="a7c4147f6c8cbcc7f07c8c968176e5c6d" name="a7c4147f6c8cbcc7f07c8c968176e5c6d"></a>
template&lt;class Vector &gt; </td></tr>
<tr class="memitem:a7c4147f6c8cbcc7f07c8c968176e5c6d"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>at</b> (const Vector &amp;key) const</td></tr>
<tr class="memdesc:a7c4147f6c8cbcc7f07c8c968176e5c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the mapped value of the element with key equivalent to key. If no such element exists, an exception of type std::out_of_range is thrown. <br /></td></tr>
<tr class="separator:a7c4147f6c8cbcc7f07c8c968176e5c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e1dd484736f197f927fff81537d451"><td class="memTemplParams" colspan="2"><a id="ac2e1dd484736f197f927fff81537d451" name="ac2e1dd484736f197f927fff81537d451"></a>
template&lt;class Vector &gt; </td></tr>
<tr class="memitem:ac2e1dd484736f197f927fff81537d451"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator[]</b> (const Vector &amp;key)</td></tr>
<tr class="memdesc:ac2e1dd484736f197f927fff81537d451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the value that is mapped to a key equivalent to key, performing an insertion if such key does not already exist. <br /></td></tr>
<tr class="separator:ac2e1dd484736f197f927fff81537d451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b2b99107da727191cedeb106f9e0bc"><td class="memTemplParams" colspan="2"><a id="ac9b2b99107da727191cedeb106f9e0bc" name="ac9b2b99107da727191cedeb106f9e0bc"></a>
template&lt;class Vector &gt; </td></tr>
<tr class="memitem:ac9b2b99107da727191cedeb106f9e0bc"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator[]</b> (Vector &amp;&amp;key)</td></tr>
<tr class="memdesc:ac9b2b99107da727191cedeb106f9e0bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the value that is mapped to a key equivalent to key, performing an insertion if such key does not already exist. <br /></td></tr>
<tr class="separator:ac9b2b99107da727191cedeb106f9e0bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49ddf81afd4316eb387d42eeb4a96bb"><td class="memItemLeft" align="right" valign="top"><a id="ac49ddf81afd4316eb387d42eeb4a96bb" name="ac49ddf81afd4316eb387d42eeb4a96bb"></a>
<a class="el" href="../../d1/deb/structbpp_1_1collections_1_1map_1_1_trie_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const</td></tr>
<tr class="memdesc:ac49ddf81afd4316eb387d42eeb4a96bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the map. If the map is empty, the returned iterator will be equal to <a class="el" href="../../d6/da7/classbpp_1_1collections_1_1map_1_1_trie.html#a1cc5f735f9dd047050902a7fc8a84b93" title="Returns an iterator to the element following the last element of the map. This element acts as a plac...">end()</a>. <br /></td></tr>
<tr class="separator:ac49ddf81afd4316eb387d42eeb4a96bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ceadba46d19e295a0abd499935d75d"><td class="memItemLeft" align="right" valign="top"><a id="a45ceadba46d19e295a0abd499935d75d" name="a45ceadba46d19e295a0abd499935d75d"></a>
<a class="el" href="../../d9/d83/structbpp_1_1collections_1_1map_1_1_trie_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin</b> () const</td></tr>
<tr class="memdesc:a45ceadba46d19e295a0abd499935d75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the first element of the map. If the map is empty, the returned iterator will be equal to <a class="el" href="../../d6/da7/classbpp_1_1collections_1_1map_1_1_trie.html#a1cc5f735f9dd047050902a7fc8a84b93" title="Returns an iterator to the element following the last element of the map. This element acts as a plac...">end()</a>. <br /></td></tr>
<tr class="separator:a45ceadba46d19e295a0abd499935d75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc5f735f9dd047050902a7fc8a84b93"><td class="memItemLeft" align="right" valign="top"><a id="a1cc5f735f9dd047050902a7fc8a84b93" name="a1cc5f735f9dd047050902a7fc8a84b93"></a>
<a class="el" href="../../d1/deb/structbpp_1_1collections_1_1map_1_1_trie_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const noexcept</td></tr>
<tr class="memdesc:a1cc5f735f9dd047050902a7fc8a84b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the map. This element acts as a placeholder; attempting to access it results in undefined behavior. <br /></td></tr>
<tr class="separator:a1cc5f735f9dd047050902a7fc8a84b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a165b75633b69b95a918ce08a519b3d3f"><td class="memItemLeft" align="right" valign="top"><a id="a165b75633b69b95a918ce08a519b3d3f" name="a165b75633b69b95a918ce08a519b3d3f"></a>
<a class="el" href="../../d9/d83/structbpp_1_1collections_1_1map_1_1_trie_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cend</b> () const noexcept</td></tr>
<tr class="memdesc:a165b75633b69b95a918ce08a519b3d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the element following the last element of the map. This element acts as a placeholder; attempting to access it results in undefined behavior. <br /></td></tr>
<tr class="separator:a165b75633b69b95a918ce08a519b3d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50610aeb7d6530762eef800c617aa88c"><td class="memItemLeft" align="right" valign="top"><a id="a50610aeb7d6530762eef800c617aa88c" name="a50610aeb7d6530762eef800c617aa88c"></a>
<a class="el" href="../../d3/dc5/structbpp_1_1collections_1_1map_1_1_trie_1_1reverse__iterator.html">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rbegin</b> () const</td></tr>
<tr class="memdesc:a50610aeb7d6530762eef800c617aa88c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed map. It corresponds to the last element of the non-reversed map. If the map is empty, the returned iterator is equal to <a class="el" href="../../d6/da7/classbpp_1_1collections_1_1map_1_1_trie.html#a04d529bbbfda252aabc386b918b6c6bb" title="Returns a reverse iterator to the element following the last element of the reversed map....">rend()</a>. <br /></td></tr>
<tr class="separator:a50610aeb7d6530762eef800c617aa88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede698b416b4b4b3ce2f40f0a5ab4f62"><td class="memItemLeft" align="right" valign="top"><a id="aede698b416b4b4b3ce2f40f0a5ab4f62" name="aede698b416b4b4b3ce2f40f0a5ab4f62"></a>
<a class="el" href="../../d3/d04/structbpp_1_1collections_1_1map_1_1_trie_1_1const__reverse__iterator.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>crbegin</b> () const</td></tr>
<tr class="memdesc:aede698b416b4b4b3ce2f40f0a5ab4f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reverse iterator to the first element of the reversed map. It corresponds to the last element of the non-reversed map. If the map is empty, the returned iterator is equal to <a class="el" href="../../d6/da7/classbpp_1_1collections_1_1map_1_1_trie.html#a04d529bbbfda252aabc386b918b6c6bb" title="Returns a reverse iterator to the element following the last element of the reversed map....">rend()</a>. <br /></td></tr>
<tr class="separator:aede698b416b4b4b3ce2f40f0a5ab4f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d529bbbfda252aabc386b918b6c6bb"><td class="memItemLeft" align="right" valign="top"><a id="a04d529bbbfda252aabc386b918b6c6bb" name="a04d529bbbfda252aabc386b918b6c6bb"></a>
<a class="el" href="../../d3/dc5/structbpp_1_1collections_1_1map_1_1_trie_1_1reverse__iterator.html">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rend</b> () const noexcept</td></tr>
<tr class="memdesc:a04d529bbbfda252aabc386b918b6c6bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed map. It corresponds to the element preceding the first element of the non-reversed map. This element acts as a placeholder, attempting to access it results in undefined behavior. <br /></td></tr>
<tr class="separator:a04d529bbbfda252aabc386b918b6c6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a92e368c9f50f3b6ae41b30881f9894"><td class="memItemLeft" align="right" valign="top"><a id="a6a92e368c9f50f3b6ae41b30881f9894" name="a6a92e368c9f50f3b6ae41b30881f9894"></a>
<a class="el" href="../../d3/d04/structbpp_1_1collections_1_1map_1_1_trie_1_1const__reverse__iterator.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>crend</b> () const noexcept</td></tr>
<tr class="memdesc:a6a92e368c9f50f3b6ae41b30881f9894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reverse iterator to the element following the last element of the reversed map. It corresponds to the element preceding the first element of the non-reversed map. This element acts as a placeholder, attempting to access it results in undefined behavior. <br /></td></tr>
<tr class="separator:a6a92e368c9f50f3b6ae41b30881f9894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f2bc041b36c00f2306428448af5a73"><td class="memItemLeft" align="right" valign="top"><a id="a45f2bc041b36c00f2306428448af5a73" name="a45f2bc041b36c00f2306428448af5a73"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty</b> () const noexcept</td></tr>
<tr class="memdesc:a45f2bc041b36c00f2306428448af5a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the container has no elements, i.e. whether <a class="el" href="../../d6/da7/classbpp_1_1collections_1_1map_1_1_trie.html#ac49ddf81afd4316eb387d42eeb4a96bb" title="Returns an iterator to the first element of the map. If the map is empty, the returned iterator will ...">begin()</a> == <a class="el" href="../../d6/da7/classbpp_1_1collections_1_1map_1_1_trie.html#a1cc5f735f9dd047050902a7fc8a84b93" title="Returns an iterator to the element following the last element of the map. This element acts as a plac...">end()</a>. <br /></td></tr>
<tr class="separator:a45f2bc041b36c00f2306428448af5a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb948c41d941785e9d4b353035e1c5c8"><td class="memItemLeft" align="right" valign="top"><a id="aeb948c41d941785e9d4b353035e1c5c8" name="aeb948c41d941785e9d4b353035e1c5c8"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const noexcept</td></tr>
<tr class="memdesc:aeb948c41d941785e9d4b353035e1c5c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the container. <br /></td></tr>
<tr class="separator:aeb948c41d941785e9d4b353035e1c5c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d789b56dfdabd3923f88abc70129ef8"><td class="memItemLeft" align="right" valign="top"><a id="a2d789b56dfdabd3923f88abc70129ef8" name="a2d789b56dfdabd3923f88abc70129ef8"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>memory</b> () const noexcept</td></tr>
<tr class="memdesc:a2d789b56dfdabd3923f88abc70129ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total space in memory. <br /></td></tr>
<tr class="separator:a2d789b56dfdabd3923f88abc70129ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5722e43e206480f2a20915599701c73"><td class="memItemLeft" align="right" valign="top"><a id="ac5722e43e206480f2a20915599701c73" name="ac5722e43e206480f2a20915599701c73"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> () noexcept</td></tr>
<tr class="memdesc:ac5722e43e206480f2a20915599701c73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements from the container. After this call, <a class="el" href="../../d6/da7/classbpp_1_1collections_1_1map_1_1_trie.html#aeb948c41d941785e9d4b353035e1c5c8" title="Returns the number of elements in the container.">size()</a> returns zero. Invalidates any references, pointers, or iterators referring to contained elements. Any past-the-end iterator remains valid. <br /></td></tr>
<tr class="separator:ac5722e43e206480f2a20915599701c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c220d7019993a5010a21fda51e2199"><td class="memTemplParams" colspan="2"><a id="a92c220d7019993a5010a21fda51e2199" name="a92c220d7019993a5010a21fda51e2199"></a>
template&lt;class Vector &gt; </td></tr>
<tr class="memitem:a92c220d7019993a5010a21fda51e2199"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="../../d1/deb/structbpp_1_1collections_1_1map_1_1_trie_1_1iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert</b> (const std::pair&lt; Vector, T &gt; &amp;value)</td></tr>
<tr class="memdesc:a92c220d7019993a5010a21fda51e2199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. Returns a pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool denoting whether the insertion took place. <br /></td></tr>
<tr class="separator:a92c220d7019993a5010a21fda51e2199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f51e40eeade243601d24d7544484b08"><td class="memTemplParams" colspan="2"><a id="a8f51e40eeade243601d24d7544484b08" name="a8f51e40eeade243601d24d7544484b08"></a>
template&lt;class Vector &gt; </td></tr>
<tr class="memitem:a8f51e40eeade243601d24d7544484b08"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="../../d1/deb/structbpp_1_1collections_1_1map_1_1_trie_1_1iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert</b> (std::pair&lt; Vector, T &gt; &amp;&amp;value)</td></tr>
<tr class="memdesc:a8f51e40eeade243601d24d7544484b08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. Returns a pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool denoting whether the insertion took place. <br /></td></tr>
<tr class="separator:a8f51e40eeade243601d24d7544484b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729befdaf5972ea6469ac1a3e77176f8"><td class="memTemplParams" colspan="2"><a id="a729befdaf5972ea6469ac1a3e77176f8" name="a729befdaf5972ea6469ac1a3e77176f8"></a>
template&lt;class Vector &gt; </td></tr>
<tr class="memitem:a729befdaf5972ea6469ac1a3e77176f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/deb/structbpp_1_1collections_1_1map_1_1_trie_1_1iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert</b> (<a class="el" href="../../d1/deb/structbpp_1_1collections_1_1map_1_1_trie_1_1iterator.html">iterator</a> hint, const std::pair&lt; Vector, T &gt; &amp;value)</td></tr>
<tr class="memdesc:a729befdaf5972ea6469ac1a3e77176f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts value in the position as close as possible to hint. Returns an iterator to the inserted element, or to the element that prevented the insertion. <br /></td></tr>
<tr class="separator:a729befdaf5972ea6469ac1a3e77176f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c070e9182df9ee5bd42c19a5815dbfa"><td class="memTemplParams" colspan="2"><a id="a1c070e9182df9ee5bd42c19a5815dbfa" name="a1c070e9182df9ee5bd42c19a5815dbfa"></a>
template&lt;class Vector &gt; </td></tr>
<tr class="memitem:a1c070e9182df9ee5bd42c19a5815dbfa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/deb/structbpp_1_1collections_1_1map_1_1_trie_1_1iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert</b> (<a class="el" href="../../d1/deb/structbpp_1_1collections_1_1map_1_1_trie_1_1iterator.html">iterator</a> hint, std::pair&lt; Vector, T &gt; &amp;&amp;value)</td></tr>
<tr class="memdesc:a1c070e9182df9ee5bd42c19a5815dbfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts value in the position as close as possible to hint. Returns an iterator to the inserted element, or to the element that prevented the insertion. <br /></td></tr>
<tr class="separator:a1c070e9182df9ee5bd42c19a5815dbfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b89707bc5f74819e8ebb94a16f940c1"><td class="memTemplParams" colspan="2"><a id="a1b89707bc5f74819e8ebb94a16f940c1" name="a1b89707bc5f74819e8ebb94a16f940c1"></a>
template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a1b89707bc5f74819e8ebb94a16f940c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert</b> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a1b89707bc5f74819e8ebb94a16f940c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from range [first, last). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted. <br /></td></tr>
<tr class="separator:a1b89707bc5f74819e8ebb94a16f940c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33528630bb6eeadd1dbadbb4ba49553"><td class="memTemplParams" colspan="2"><a id="ab33528630bb6eeadd1dbadbb4ba49553" name="ab33528630bb6eeadd1dbadbb4ba49553"></a>
template&lt;class Vector &gt; </td></tr>
<tr class="memitem:ab33528630bb6eeadd1dbadbb4ba49553"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert</b> (std::initializer_list&lt; std::pair&lt; Vector, T &gt; &gt; ilist)</td></tr>
<tr class="memdesc:ab33528630bb6eeadd1dbadbb4ba49553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from initializer list ilist. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted. <br /></td></tr>
<tr class="separator:ab33528630bb6eeadd1dbadbb4ba49553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86986c19f4d1a703d2c080a477b015ab"><td class="memTemplParams" colspan="2"><a id="a86986c19f4d1a703d2c080a477b015ab" name="a86986c19f4d1a703d2c080a477b015ab"></a>
template&lt;class Vector , class M &gt; </td></tr>
<tr class="memitem:a86986c19f4d1a703d2c080a477b015ab"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="../../d1/deb/structbpp_1_1collections_1_1map_1_1_trie_1_1iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_or_assign</b> (const Vector &amp;k, M &amp;&amp;obj)</td></tr>
<tr class="memdesc:a86986c19f4d1a703d2c080a477b015ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a key equivalent to k already exists in the container, assigns obj to the mapped_type corresponding to the key k. If the key does not exist, inserts the new value as if by insert. <br /></td></tr>
<tr class="separator:a86986c19f4d1a703d2c080a477b015ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02a2407ddb34f806a41e41b59fd757e"><td class="memTemplParams" colspan="2"><a id="ab02a2407ddb34f806a41e41b59fd757e" name="ab02a2407ddb34f806a41e41b59fd757e"></a>
template&lt;class Vector , class M &gt; </td></tr>
<tr class="memitem:ab02a2407ddb34f806a41e41b59fd757e"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="../../d1/deb/structbpp_1_1collections_1_1map_1_1_trie_1_1iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_or_assign</b> (Vector &amp;&amp;k, M &amp;&amp;obj)</td></tr>
<tr class="memdesc:ab02a2407ddb34f806a41e41b59fd757e"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a key equivalent to k already exists in the container, assigns obj to the mapped_type corresponding to the key k. If the key does not exist, inserts the new value as if by insert. <br /></td></tr>
<tr class="separator:ab02a2407ddb34f806a41e41b59fd757e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24eb7fab8b11b547a12ca399686d622"><td class="memTemplParams" colspan="2"><a id="ab24eb7fab8b11b547a12ca399686d622" name="ab24eb7fab8b11b547a12ca399686d622"></a>
template&lt;class Vector , class M &gt; </td></tr>
<tr class="memitem:ab24eb7fab8b11b547a12ca399686d622"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="../../d1/deb/structbpp_1_1collections_1_1map_1_1_trie_1_1iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_or_assign</b> (<a class="el" href="../../d1/deb/structbpp_1_1collections_1_1map_1_1_trie_1_1iterator.html">iterator</a> hint, const Vector &amp;k, M &amp;&amp;obj)</td></tr>
<tr class="memdesc:ab24eb7fab8b11b547a12ca399686d622"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a key equivalent to k already exists in the container, assigns obj to the mapped_type corresponding to the key k. If the key does not exist, inserts the new value as if by insert. <br /></td></tr>
<tr class="separator:ab24eb7fab8b11b547a12ca399686d622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5fbaa6a8f573abd250c2e5f2a02c7d8"><td class="memTemplParams" colspan="2"><a id="aa5fbaa6a8f573abd250c2e5f2a02c7d8" name="aa5fbaa6a8f573abd250c2e5f2a02c7d8"></a>
template&lt;class Vector , class M &gt; </td></tr>
<tr class="memitem:aa5fbaa6a8f573abd250c2e5f2a02c7d8"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="../../d1/deb/structbpp_1_1collections_1_1map_1_1_trie_1_1iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_or_assign</b> (<a class="el" href="../../d1/deb/structbpp_1_1collections_1_1map_1_1_trie_1_1iterator.html">iterator</a> hint, Vector &amp;&amp;k, M &amp;&amp;obj)</td></tr>
<tr class="memdesc:aa5fbaa6a8f573abd250c2e5f2a02c7d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a key equivalent to k already exists in the container, assigns obj to the mapped_type corresponding to the key k. If the key does not exist, inserts the new value as if by insert. <br /></td></tr>
<tr class="separator:aa5fbaa6a8f573abd250c2e5f2a02c7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5f0041cfdfe39a341297ceeb72e67d"><td class="memItemLeft" align="right" valign="top"><a id="aaf5f0041cfdfe39a341297ceeb72e67d" name="aaf5f0041cfdfe39a341297ceeb72e67d"></a>
<a class="el" href="../../d1/deb/structbpp_1_1collections_1_1map_1_1_trie_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (<a class="el" href="../../d1/deb/structbpp_1_1collections_1_1map_1_1_trie_1_1iterator.html">iterator</a> pos)</td></tr>
<tr class="memdesc:aaf5f0041cfdfe39a341297ceeb72e67d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes element at pos from the container. Returns iterator following the last removed element. <br /></td></tr>
<tr class="separator:aaf5f0041cfdfe39a341297ceeb72e67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d5fa26d88720afab8919835c929bfb"><td class="memItemLeft" align="right" valign="top"><a id="ab7d5fa26d88720afab8919835c929bfb" name="ab7d5fa26d88720afab8919835c929bfb"></a>
<a class="el" href="../../d1/deb/structbpp_1_1collections_1_1map_1_1_trie_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (<a class="el" href="../../d1/deb/structbpp_1_1collections_1_1map_1_1_trie_1_1iterator.html">iterator</a> first, <a class="el" href="../../d1/deb/structbpp_1_1collections_1_1map_1_1_trie_1_1iterator.html">iterator</a> last)</td></tr>
<tr class="memdesc:ab7d5fa26d88720afab8919835c929bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the elements in the range [first; last), which must be a valid range in *this. <br /></td></tr>
<tr class="separator:ab7d5fa26d88720afab8919835c929bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5699755196af66d3c897a2db6666eef6"><td class="memTemplParams" colspan="2"><a id="a5699755196af66d3c897a2db6666eef6" name="a5699755196af66d3c897a2db6666eef6"></a>
template&lt;class Vector &gt; </td></tr>
<tr class="memitem:a5699755196af66d3c897a2db6666eef6"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>erase</b> (const Vector &amp;key)</td></tr>
<tr class="memdesc:a5699755196af66d3c897a2db6666eef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element (if one exists) with the key equivalent to key. Returns the number of elements removed (0 or 1). <br /></td></tr>
<tr class="separator:a5699755196af66d3c897a2db6666eef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18987075cb5e65afc688e8d41ee24088"><td class="memTemplParams" colspan="2"><a id="a18987075cb5e65afc688e8d41ee24088" name="a18987075cb5e65afc688e8d41ee24088"></a>
template&lt;class Vector &gt; </td></tr>
<tr class="memitem:a18987075cb5e65afc688e8d41ee24088"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>erase</b> (Vector &amp;&amp;key)</td></tr>
<tr class="memdesc:a18987075cb5e65afc688e8d41ee24088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element (if one exists) with the key equivalent to key. Returns the number of elements removed (0 or 1). <br /></td></tr>
<tr class="separator:a18987075cb5e65afc688e8d41ee24088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e5d6f22d7c77a96c8903cd785c7f1b"><td class="memTemplParams" colspan="2"><a id="aa7e5d6f22d7c77a96c8903cd785c7f1b" name="aa7e5d6f22d7c77a96c8903cd785c7f1b"></a>
template&lt;class K &gt; </td></tr>
<tr class="memitem:aa7e5d6f22d7c77a96c8903cd785c7f1b"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>count</b> (const K &amp;key) const</td></tr>
<tr class="memdesc:aa7e5d6f22d7c77a96c8903cd785c7f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements with key that compares equivalent to the specified key, which is either 1 or 0 since this container does not allow duplicates. <br /></td></tr>
<tr class="separator:aa7e5d6f22d7c77a96c8903cd785c7f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c218e308cc9eb283d7d59e5e0993ff"><td class="memTemplParams" colspan="2"><a id="a32c218e308cc9eb283d7d59e5e0993ff" name="a32c218e308cc9eb283d7d59e5e0993ff"></a>
template&lt;class K &gt; </td></tr>
<tr class="memitem:a32c218e308cc9eb283d7d59e5e0993ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/deb/structbpp_1_1collections_1_1map_1_1_trie_1_1iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find</b> (const K &amp;key)</td></tr>
<tr class="memdesc:a32c218e308cc9eb283d7d59e5e0993ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equivalent to key and returns an iterator to the element. If no such element is found, past-the-end (see <a class="el" href="../../d6/da7/classbpp_1_1collections_1_1map_1_1_trie.html#a1cc5f735f9dd047050902a7fc8a84b93" title="Returns an iterator to the element following the last element of the map. This element acts as a plac...">end()</a>) iterator is returned. <br /></td></tr>
<tr class="separator:a32c218e308cc9eb283d7d59e5e0993ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6f0bd3f2a7d263789309071540e39c"><td class="memTemplParams" colspan="2"><a id="a4e6f0bd3f2a7d263789309071540e39c" name="a4e6f0bd3f2a7d263789309071540e39c"></a>
template&lt;class K &gt; </td></tr>
<tr class="memitem:a4e6f0bd3f2a7d263789309071540e39c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>contains</b> (const K &amp;key) const</td></tr>
<tr class="memdesc:a4e6f0bd3f2a7d263789309071540e39c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there is an element with key that compares equivalent to the value x. <br /></td></tr>
<tr class="separator:a4e6f0bd3f2a7d263789309071540e39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab68526ddebc0aa25c73236babd5e74"><td class="memTemplParams" colspan="2"><a id="abab68526ddebc0aa25c73236babd5e74" name="abab68526ddebc0aa25c73236babd5e74"></a>
template&lt;class K &gt; </td></tr>
<tr class="memitem:abab68526ddebc0aa25c73236babd5e74"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/deb/structbpp_1_1collections_1_1map_1_1_trie_1_1iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>lower_bound</b> (const K &amp;key)</td></tr>
<tr class="memdesc:abab68526ddebc0aa25c73236babd5e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that compares not less (i.e. greater or equal) to the value x. If no such element is found, past-the-end (see <a class="el" href="../../d6/da7/classbpp_1_1collections_1_1map_1_1_trie.html#a1cc5f735f9dd047050902a7fc8a84b93" title="Returns an iterator to the element following the last element of the map. This element acts as a plac...">end()</a>) iterator is returned. <br /></td></tr>
<tr class="separator:abab68526ddebc0aa25c73236babd5e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591e3417ffbfc0301ebd8ec0b27b7352"><td class="memTemplParams" colspan="2"><a id="a591e3417ffbfc0301ebd8ec0b27b7352" name="a591e3417ffbfc0301ebd8ec0b27b7352"></a>
template&lt;class K &gt; </td></tr>
<tr class="memitem:a591e3417ffbfc0301ebd8ec0b27b7352"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/deb/structbpp_1_1collections_1_1map_1_1_trie_1_1iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>upper_bound</b> (const K &amp;key)</td></tr>
<tr class="memdesc:a591e3417ffbfc0301ebd8ec0b27b7352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that compares greater to the value x. If no such element is found, past-the-end (see <a class="el" href="../../d6/da7/classbpp_1_1collections_1_1map_1_1_trie.html#a1cc5f735f9dd047050902a7fc8a84b93" title="Returns an iterator to the element following the last element of the map. This element acts as a plac...">end()</a>) iterator is returned. <br /></td></tr>
<tr class="separator:a591e3417ffbfc0301ebd8ec0b27b7352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ade18be887e882497a491de2344b47"><td class="memTemplParams" colspan="2"><a id="a51ade18be887e882497a491de2344b47" name="a51ade18be887e882497a491de2344b47"></a>
template&lt;class K &gt; </td></tr>
<tr class="memitem:a51ade18be887e882497a491de2344b47"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="../../d1/deb/structbpp_1_1collections_1_1map_1_1_trie_1_1iterator.html">iterator</a>, <a class="el" href="../../d1/deb/structbpp_1_1collections_1_1map_1_1_trie_1_1iterator.html">iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>equal_range</b> (const K &amp;key)</td></tr>
<tr class="memdesc:a51ade18be887e882497a491de2344b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="../../d6/da7/classbpp_1_1collections_1_1map_1_1_trie.html#abab68526ddebc0aa25c73236babd5e74" title="Returns an iterator pointing to the first element that compares not less (i.e. greater or equal) to t...">lower_bound()</a>, and the second with <a class="el" href="../../d6/da7/classbpp_1_1collections_1_1map_1_1_trie.html#a591e3417ffbfc0301ebd8ec0b27b7352" title="Returns an iterator pointing to the first element that compares greater to the value x....">upper_bound()</a>. <br /></td></tr>
<tr class="separator:a51ade18be887e882497a491de2344b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ad94a6e92c2ca0513dcaef0df37f08783"><td class="memTemplParams" colspan="2"><a id="ad94a6e92c2ca0513dcaef0df37f08783" name="ad94a6e92c2ca0513dcaef0df37f08783"></a>
template&lt;typename Buff , typename... Types&gt; </td></tr>
<tr class="memitem:ad94a6e92c2ca0513dcaef0df37f08783"><td class="memTemplItemLeft" align="right" valign="top">struct&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/da7/classbpp_1_1collections_1_1map_1_1_trie.html#ad94a6e92c2ca0513dcaef0df37f08783">bpp::collections::serialize::Serialize</a></td></tr>
<tr class="memdesc:ad94a6e92c2ca0513dcaef0df37f08783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the Serialize template to support <a class="el" href="../../d6/da7/classbpp_1_1collections_1_1map_1_1_trie.html" title="Trie is a sorted associative container that contains key-value pairs with unique keys....">Trie</a> objects. <br /></td></tr>
<tr class="separator:ad94a6e92c2ca0513dcaef0df37f08783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a53f4fc48b1a523857b39bb742625d1"><td class="memTemplParams" colspan="2"><a id="a4a53f4fc48b1a523857b39bb742625d1" name="a4a53f4fc48b1a523857b39bb742625d1"></a>
template&lt;typename Buff , typename... Types&gt; </td></tr>
<tr class="memitem:a4a53f4fc48b1a523857b39bb742625d1"><td class="memTemplItemLeft" align="right" valign="top">struct&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/da7/classbpp_1_1collections_1_1map_1_1_trie.html#a4a53f4fc48b1a523857b39bb742625d1">bpp::collections::serialize::Deserialize</a></td></tr>
<tr class="memdesc:a4a53f4fc48b1a523857b39bb742625d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the Deserialize template to support <a class="el" href="../../d6/da7/classbpp_1_1collections_1_1map_1_1_trie.html" title="Trie is a sorted associative container that contains key-value pairs with unique keys....">Trie</a> objects. <br /></td></tr>
<tr class="separator:a4a53f4fc48b1a523857b39bb742625d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61efb4a192ab6be18faea4a41a4350c"><td class="memTemplParams" colspan="2"><a id="af61efb4a192ab6be18faea4a41a4350c" name="af61efb4a192ab6be18faea4a41a4350c"></a>
template&lt;class A , class B , class C , class D &gt; </td></tr>
<tr class="memitem:af61efb4a192ab6be18faea4a41a4350c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d6/da7/classbpp_1_1collections_1_1map_1_1_trie.html">Trie</a>&lt; A, B, C, D &gt; &amp;lhs, const <a class="el" href="../../d6/da7/classbpp_1_1collections_1_1map_1_1_trie.html">Trie</a>&lt; A, B, C, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:af61efb4a192ab6be18faea4a41a4350c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the contents of lhs and rhs are equal, that is, they have the same number of elements and each element in lhs compares equal with the element in rhs at the same position. <br /></td></tr>
<tr class="separator:af61efb4a192ab6be18faea4a41a4350c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62322f4f3ae1075aaa2c5984cbba2ad7"><td class="memTemplParams" colspan="2"><a id="a62322f4f3ae1075aaa2c5984cbba2ad7" name="a62322f4f3ae1075aaa2c5984cbba2ad7"></a>
template&lt;class A , class B , class C , class D &gt; </td></tr>
<tr class="memitem:a62322f4f3ae1075aaa2c5984cbba2ad7"><td class="memTemplItemLeft" align="right" valign="top">std::strong_ordering&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=&gt;</b> (const <a class="el" href="../../d6/da7/classbpp_1_1collections_1_1map_1_1_trie.html">Trie</a>&lt; A, B, C, D &gt; &amp;lhs, const <a class="el" href="../../d6/da7/classbpp_1_1collections_1_1map_1_1_trie.html">Trie</a>&lt; A, B, C, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a62322f4f3ae1075aaa2c5984cbba2ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of lhs and rhs lexicographically. <br /></td></tr>
<tr class="separator:a62322f4f3ae1075aaa2c5984cbba2ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675cdf92368472cfe4bbf74478e49289"><td class="memTemplParams" colspan="2"><a id="a675cdf92368472cfe4bbf74478e49289" name="a675cdf92368472cfe4bbf74478e49289"></a>
template&lt;class A , class B , class C , class D , class Pred &gt; </td></tr>
<tr class="memitem:a675cdf92368472cfe4bbf74478e49289"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::erase_if</b> (<a class="el" href="../../d6/da7/classbpp_1_1collections_1_1map_1_1_trie.html">Trie</a>&lt; A, B, C, D &gt; &amp;trie, Pred pred)</td></tr>
<tr class="memdesc:a675cdf92368472cfe4bbf74478e49289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements that satisfy the predicate pred from the container. <br /></td></tr>
<tr class="separator:a675cdf92368472cfe4bbf74478e49289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487ec6e6eb7ca87734a9a9b1f8f60e98"><td class="memTemplParams" colspan="2"><a id="a487ec6e6eb7ca87734a9a9b1f8f60e98" name="a487ec6e6eb7ca87734a9a9b1f8f60e98"></a>
template&lt;class A , class B , class C , class D &gt; </td></tr>
<tr class="memitem:a487ec6e6eb7ca87734a9a9b1f8f60e98"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::swap</b> (<a class="el" href="../../d6/da7/classbpp_1_1collections_1_1map_1_1_trie.html">Trie</a>&lt; A, B, C, D &gt; &amp;lhs, <a class="el" href="../../d6/da7/classbpp_1_1collections_1_1map_1_1_trie.html">Trie</a>&lt; A, B, C, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a487ec6e6eb7ca87734a9a9b1f8f60e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized swapping function. <br /></td></tr>
<tr class="separator:a487ec6e6eb7ca87734a9a9b1f8f60e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class Key, class T, class Container = std::map&lt;Key, void*&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;<br />
class bpp::collections::map::Trie&lt; Key, T, Container, Allocator &gt;</div><p ><a class="el" href="../../d6/da7/classbpp_1_1collections_1_1map_1_1_trie.html" title="Trie is a sorted associative container that contains key-value pairs with unique keys....">Trie</a> is a sorted associative container that contains key-value pairs with unique keys. Any indexed collection can be used as key for the <a class="el" href="../../d6/da7/classbpp_1_1collections_1_1map_1_1_trie.html" title="Trie is a sorted associative container that contains key-value pairs with unique keys....">Trie</a>, but the base type should be specified. The Container support class can be specified but by default std::map is used. Keys are sorted by using the comparison function within Container. Search, removal, and insertion operations have loglinear complexity. This is an implementation of a trie/prefix tree structure. </p>
</div><hr/>The documentation for this class was generated from the following file:<ul>
<li>Collections/<a class="el" href="../../db/d43/_trie_8h_source.html">Trie.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
